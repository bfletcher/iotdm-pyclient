#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Thu Jul 14 17:00:13 2016 by generateDS.py version 2.18a.
#
# Command line options:
#   ('-o', 'node.py')
#
# Command line arguments:
#   shortName-XSD-v2_3_0/CDT-node-v2_3_0.xsd
#
# Command line:
#   generateDS.py -o "node.py" shortName-XSD-v2_3_0/CDT-node-v2_3_0.xsd
#
# Current working directory (os.getcwd()):
#   generateDS-2.18a0
#

import sys
import re as re_
import base64
import datetime as datetime_
import warnings as warnings_
from lxml import etree as etree_
from onem2m_xml_protocols.common import announceableResource


Validate_simpletypes_ = True


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        parser = etree_.ETCompatXMLParser()
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError as exp:

    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return values
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_validate_float(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(
                        node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (time_parts[0], micro_seconds, )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.  We should:
            # - AND the outer elements
            # - OR the inner elements
            found1 = True
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    if re_.search(patterns2, target) is not None:
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.iteritems()))


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'ascii'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace, pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, namespace, name, pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name, base64.b64encode(self.value), self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0):
        self.name = name
        self.data_type = data_type
        self.container = container
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class nod(announceableResource):
    subclass = None
    superclass = None
    def __init__(self, ni=None, hcl=None, ch=None, mem=None, bat=None, ani=None, andi=None, fwr=None, swr=None, dvi=None, dvc=None, rbo=None, evl=None, cmp=None, acmp=None, sub=None):
        self.original_tagname_ = None
        self.ni = ni
        self.hcl = hcl
        # if ch is None:
        #     self.ch = []
        # else:
        #     self.ch = ch
        # if mem is None:
        #     self.mem = []
        # else:
        #     self.mem = mem
        # if bat is None:
        #     self.bat = []
        # else:
        #     self.bat = bat
        # if ani is None:
        #     self.ani = []
        # else:
        #     self.ani = ani
        # if andi is None:
        #     self.andi = []
        # else:
        #     self.andi = andi
        # if fwr is None:
        #     self.fwr = []
        # else:
        #     self.fwr = fwr
        # if swr is None:
        #     self.swr = []
        # else:
        #     self.swr = swr
        # if dvi is None:
        #     self.dvi = []
        # else:
        #     self.dvi = dvi
        # if dvc is None:
        #     self.dvc = []
        # else:
        #     self.dvc = dvc
        # if rbo is None:
        #     self.rbo = []
        # else:
        #     self.rbo = rbo
        # if evl is None:
        #     self.evl = []
        # else:
        #     self.evl = evl
        # if cmp is None:
        #     self.cmp = []
        # else:
        #     self.cmp = cmp
        # if acmp is None:
        #     self.acmp = []
        # else:
        #     self.acmp = acmp
        # if sub is None:
        #     self.sub = []
        # else:
        #     self.sub = sub
    def factory(*args_, **kwargs_):
        if nod.subclass:
            return nod.subclass(*args_, **kwargs_)
        else:
            return nod(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ni(self): return self.ni
    def set_ni(self, ni): self.ni = ni
    def get_hcl(self): return self.hcl
    def set_hcl(self, hcl): self.hcl = hcl
    def get_ch(self): return self.ch
    def set_ch(self, ch): self.ch = ch
    def add_ch(self, value): self.ch.append(value)
    def insert_ch_at(self, index, value): self.ch.insert(index, value)
    def replace_ch_at(self, index, value): self.ch[index] = value
    def get_mem(self): return self.mem
    def set_mem(self, mem): self.mem = mem
    def add_mem(self, value): self.mem.append(value)
    def insert_mem_at(self, index, value): self.mem.insert(index, value)
    def replace_mem_at(self, index, value): self.mem[index] = value
    def get_bat(self): return self.bat
    def set_bat(self, bat): self.bat = bat
    def add_bat(self, value): self.bat.append(value)
    def insert_bat_at(self, index, value): self.bat.insert(index, value)
    def replace_bat_at(self, index, value): self.bat[index] = value
    def get_ani(self): return self.ani
    def set_ani(self, ani): self.ani = ani
    def add_ani(self, value): self.ani.append(value)
    def insert_ani_at(self, index, value): self.ani.insert(index, value)
    def replace_ani_at(self, index, value): self.ani[index] = value
    def get_andi(self): return self.andi
    def set_andi(self, andi): self.andi = andi
    def add_andi(self, value): self.andi.append(value)
    def insert_andi_at(self, index, value): self.andi.insert(index, value)
    def replace_andi_at(self, index, value): self.andi[index] = value
    def get_fwr(self): return self.fwr
    def set_fwr(self, fwr): self.fwr = fwr
    def add_fwr(self, value): self.fwr.append(value)
    def insert_fwr_at(self, index, value): self.fwr.insert(index, value)
    def replace_fwr_at(self, index, value): self.fwr[index] = value
    def get_swr(self): return self.swr
    def set_swr(self, swr): self.swr = swr
    def add_swr(self, value): self.swr.append(value)
    def insert_swr_at(self, index, value): self.swr.insert(index, value)
    def replace_swr_at(self, index, value): self.swr[index] = value
    def get_dvi(self): return self.dvi
    def set_dvi(self, dvi): self.dvi = dvi
    def add_dvi(self, value): self.dvi.append(value)
    def insert_dvi_at(self, index, value): self.dvi.insert(index, value)
    def replace_dvi_at(self, index, value): self.dvi[index] = value
    def get_dvc(self): return self.dvc
    def set_dvc(self, dvc): self.dvc = dvc
    def add_dvc(self, value): self.dvc.append(value)
    def insert_dvc_at(self, index, value): self.dvc.insert(index, value)
    def replace_dvc_at(self, index, value): self.dvc[index] = value
    def get_rbo(self): return self.rbo
    def set_rbo(self, rbo): self.rbo = rbo
    def add_rbo(self, value): self.rbo.append(value)
    def insert_rbo_at(self, index, value): self.rbo.insert(index, value)
    def replace_rbo_at(self, index, value): self.rbo[index] = value
    def get_evl(self): return self.evl
    def set_evl(self, evl): self.evl = evl
    def add_evl(self, value): self.evl.append(value)
    def insert_evl_at(self, index, value): self.evl.insert(index, value)
    def replace_evl_at(self, index, value): self.evl[index] = value
    def get_cmp(self): return self.cmp
    def set_cmp(self, cmp): self.cmp = cmp
    def add_cmp(self, value): self.cmp.append(value)
    def insert_cmp_at(self, index, value): self.cmp.insert(index, value)
    def replace_cmp_at(self, index, value): self.cmp[index] = value
    def get_acmp(self): return self.acmp
    def set_acmp(self, acmp): self.acmp = acmp
    def add_acmp(self, value): self.acmp.append(value)
    def insert_acmp_at(self, index, value): self.acmp.insert(index, value)
    def replace_acmp_at(self, index, value): self.acmp[index] = value
    def get_sub(self): return self.sub
    def set_sub(self, sub): self.sub = sub
    def add_sub(self, value): self.sub.append(value)
    def insert_sub_at(self, index, value): self.sub.insert(index, value)
    def replace_sub_at(self, index, value): self.sub[index] = value
    def hasContent_(self):
        if (
            self.ni is not None or
            self.hcl is not None or
            self.ch or
            self.mem or
            self.bat or
            self.ani or
            self.andi or
            self.fwr or
            self.swr or
            self.dvi or
            self.dvc or
            self.rbo or
            self.evl or
            self.cmp or
            self.acmp or
            self.sub
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='m2m:', name_='nod', namespacedef_='xmlns:m2m="http://www.onem2m.org/xml/protocols"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='nod')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='m2m:', name_='nod', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='m2m:', name_='nod'):
        pass
    def exportChildren(self, outfile, level, namespace_='m2m:', name_='nod', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ni is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sni>%s</%sni>%s' % (namespace_, self.gds_format_string(quote_xml(self.ni).encode(ExternalEncoding), input_name='ni'), namespace_, eol_))
        if self.hcl is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%shcl>%s</%shcl>%s' % (namespace_, self.gds_format_string(quote_xml(self.hcl).encode(ExternalEncoding), input_name='hcl'), namespace_, eol_))
        for ch_ in self.ch:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sch>%s</%sch>%s' % (namespace_, self.gds_format_string(quote_xml(ch_).encode(ExternalEncoding), input_name='ch'), namespace_, eol_))
        for mem_ in self.mem:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smem>%s</%smem>%s' % (namespace_, self.gds_format_string(quote_xml(mem_).encode(ExternalEncoding), input_name='mem'), namespace_, eol_))
        for bat_ in self.bat:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbat>%s</%sbat>%s' % (namespace_, self.gds_format_string(quote_xml(bat_).encode(ExternalEncoding), input_name='bat'), namespace_, eol_))
        for ani_ in self.ani:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sani>%s</%sani>%s' % (namespace_, self.gds_format_string(quote_xml(ani_).encode(ExternalEncoding), input_name='ani'), namespace_, eol_))
        for andi_ in self.andi:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sandi>%s</%sandi>%s' % (namespace_, self.gds_format_string(quote_xml(andi_).encode(ExternalEncoding), input_name='andi'), namespace_, eol_))
        for fwr_ in self.fwr:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfwr>%s</%sfwr>%s' % (namespace_, self.gds_format_string(quote_xml(fwr_).encode(ExternalEncoding), input_name='fwr'), namespace_, eol_))
        for swr_ in self.swr:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sswr>%s</%sswr>%s' % (namespace_, self.gds_format_string(quote_xml(swr_).encode(ExternalEncoding), input_name='swr'), namespace_, eol_))
        for dvi_ in self.dvi:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdvi>%s</%sdvi>%s' % (namespace_, self.gds_format_string(quote_xml(dvi_).encode(ExternalEncoding), input_name='dvi'), namespace_, eol_))
        for dvc_ in self.dvc:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdvc>%s</%sdvc>%s' % (namespace_, self.gds_format_string(quote_xml(dvc_).encode(ExternalEncoding), input_name='dvc'), namespace_, eol_))
        for rbo_ in self.rbo:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srbo>%s</%srbo>%s' % (namespace_, self.gds_format_string(quote_xml(rbo_).encode(ExternalEncoding), input_name='rbo'), namespace_, eol_))
        for evl_ in self.evl:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sevl>%s</%sevl>%s' % (namespace_, self.gds_format_string(quote_xml(evl_).encode(ExternalEncoding), input_name='evl'), namespace_, eol_))
        for cmp_ in self.cmp:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scmp>%s</%scmp>%s' % (namespace_, self.gds_format_string(quote_xml(cmp_).encode(ExternalEncoding), input_name='cmp'), namespace_, eol_))
        for acmp_ in self.acmp:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sacmp>%s</%sacmp>%s' % (namespace_, self.gds_format_string(quote_xml(acmp_).encode(ExternalEncoding), input_name='acmp'), namespace_, eol_))
        for sub_ in self.sub:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssub>%s</%ssub>%s' % (namespace_, self.gds_format_string(quote_xml(sub_).encode(ExternalEncoding), input_name='sub'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ni':
            ni_ = child_.text
            ni_ = self.gds_validate_string(ni_, node, 'ni')
            self.ni = ni_
        elif nodeName_ == 'hcl':
            hcl_ = child_.text
            hcl_ = self.gds_validate_string(hcl_, node, 'hcl')
            self.hcl = hcl_
        elif nodeName_ == 'ch':
            ch_ = child_.text
            ch_ = self.gds_validate_string(ch_, node, 'ch')
            self.ch.append(ch_)
        elif nodeName_ == 'mem':
            mem_ = child_.text
            mem_ = self.gds_validate_string(mem_, node, 'mem')
            self.mem.append(mem_)
        elif nodeName_ == 'bat':
            bat_ = child_.text
            bat_ = self.gds_validate_string(bat_, node, 'bat')
            self.bat.append(bat_)
        elif nodeName_ == 'ani':
            ani_ = child_.text
            ani_ = self.gds_validate_string(ani_, node, 'ani')
            self.ani.append(ani_)
        elif nodeName_ == 'andi':
            andi_ = child_.text
            andi_ = self.gds_validate_string(andi_, node, 'andi')
            self.andi.append(andi_)
        elif nodeName_ == 'fwr':
            fwr_ = child_.text
            fwr_ = self.gds_validate_string(fwr_, node, 'fwr')
            self.fwr.append(fwr_)
        elif nodeName_ == 'swr':
            swr_ = child_.text
            swr_ = self.gds_validate_string(swr_, node, 'swr')
            self.swr.append(swr_)
        elif nodeName_ == 'dvi':
            dvi_ = child_.text
            dvi_ = self.gds_validate_string(dvi_, node, 'dvi')
            self.dvi.append(dvi_)
        elif nodeName_ == 'dvc':
            dvc_ = child_.text
            dvc_ = self.gds_validate_string(dvc_, node, 'dvc')
            self.dvc.append(dvc_)
        elif nodeName_ == 'rbo':
            rbo_ = child_.text
            rbo_ = self.gds_validate_string(rbo_, node, 'rbo')
            self.rbo.append(rbo_)
        elif nodeName_ == 'evl':
            evl_ = child_.text
            evl_ = self.gds_validate_string(evl_, node, 'evl')
            self.evl.append(evl_)
        elif nodeName_ == 'cmp':
            cmp_ = child_.text
            cmp_ = self.gds_validate_string(cmp_, node, 'cmp')
            self.cmp.append(cmp_)
        elif nodeName_ == 'acmp':
            acmp_ = child_.text
            acmp_ = self.gds_validate_string(acmp_, node, 'acmp')
            self.acmp.append(acmp_)
        elif nodeName_ == 'sub':
            sub_ = child_.text
            sub_ = self.gds_validate_string(sub_, node, 'sub')
            self.sub.append(sub_)
        super(nod, self).buildChildren(child_, node, nodeName_, True)
# end class nod


class nodA(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ni=None, hcl=None, ch=None, memA=None, batA=None, aniA=None, andiA=None, fwrA=None, swrA=None, dviA=None, dvcA=None, rboA=None, evlA=None, sub=None):
        self.original_tagname_ = None
        self.ni = ni
        self.hcl = hcl
        if ch is None:
            self.ch = []
        else:
            self.ch = ch
        if memA is None:
            self.memA = []
        else:
            self.memA = memA
        if batA is None:
            self.batA = []
        else:
            self.batA = batA
        if aniA is None:
            self.aniA = []
        else:
            self.aniA = aniA
        if andiA is None:
            self.andiA = []
        else:
            self.andiA = andiA
        if fwrA is None:
            self.fwrA = []
        else:
            self.fwrA = fwrA
        if swrA is None:
            self.swrA = []
        else:
            self.swrA = swrA
        if dviA is None:
            self.dviA = []
        else:
            self.dviA = dviA
        if dvcA is None:
            self.dvcA = []
        else:
            self.dvcA = dvcA
        if rboA is None:
            self.rboA = []
        else:
            self.rboA = rboA
        if evlA is None:
            self.evlA = []
        else:
            self.evlA = evlA
        if sub is None:
            self.sub = []
        else:
            self.sub = sub
    def factory(*args_, **kwargs_):
        if nodA.subclass:
            return nodA.subclass(*args_, **kwargs_)
        else:
            return nodA(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ni(self): return self.ni
    def set_ni(self, ni): self.ni = ni
    def get_hcl(self): return self.hcl
    def set_hcl(self, hcl): self.hcl = hcl
    def get_ch(self): return self.ch
    def set_ch(self, ch): self.ch = ch
    def add_ch(self, value): self.ch.append(value)
    def insert_ch_at(self, index, value): self.ch.insert(index, value)
    def replace_ch_at(self, index, value): self.ch[index] = value
    def get_memA(self): return self.memA
    def set_memA(self, memA): self.memA = memA
    def add_memA(self, value): self.memA.append(value)
    def insert_memA_at(self, index, value): self.memA.insert(index, value)
    def replace_memA_at(self, index, value): self.memA[index] = value
    def get_batA(self): return self.batA
    def set_batA(self, batA): self.batA = batA
    def add_batA(self, value): self.batA.append(value)
    def insert_batA_at(self, index, value): self.batA.insert(index, value)
    def replace_batA_at(self, index, value): self.batA[index] = value
    def get_aniA(self): return self.aniA
    def set_aniA(self, aniA): self.aniA = aniA
    def add_aniA(self, value): self.aniA.append(value)
    def insert_aniA_at(self, index, value): self.aniA.insert(index, value)
    def replace_aniA_at(self, index, value): self.aniA[index] = value
    def get_andiA(self): return self.andiA
    def set_andiA(self, andiA): self.andiA = andiA
    def add_andiA(self, value): self.andiA.append(value)
    def insert_andiA_at(self, index, value): self.andiA.insert(index, value)
    def replace_andiA_at(self, index, value): self.andiA[index] = value
    def get_fwrA(self): return self.fwrA
    def set_fwrA(self, fwrA): self.fwrA = fwrA
    def add_fwrA(self, value): self.fwrA.append(value)
    def insert_fwrA_at(self, index, value): self.fwrA.insert(index, value)
    def replace_fwrA_at(self, index, value): self.fwrA[index] = value
    def get_swrA(self): return self.swrA
    def set_swrA(self, swrA): self.swrA = swrA
    def add_swrA(self, value): self.swrA.append(value)
    def insert_swrA_at(self, index, value): self.swrA.insert(index, value)
    def replace_swrA_at(self, index, value): self.swrA[index] = value
    def get_dviA(self): return self.dviA
    def set_dviA(self, dviA): self.dviA = dviA
    def add_dviA(self, value): self.dviA.append(value)
    def insert_dviA_at(self, index, value): self.dviA.insert(index, value)
    def replace_dviA_at(self, index, value): self.dviA[index] = value
    def get_dvcA(self): return self.dvcA
    def set_dvcA(self, dvcA): self.dvcA = dvcA
    def add_dvcA(self, value): self.dvcA.append(value)
    def insert_dvcA_at(self, index, value): self.dvcA.insert(index, value)
    def replace_dvcA_at(self, index, value): self.dvcA[index] = value
    def get_rboA(self): return self.rboA
    def set_rboA(self, rboA): self.rboA = rboA
    def add_rboA(self, value): self.rboA.append(value)
    def insert_rboA_at(self, index, value): self.rboA.insert(index, value)
    def replace_rboA_at(self, index, value): self.rboA[index] = value
    def get_evlA(self): return self.evlA
    def set_evlA(self, evlA): self.evlA = evlA
    def add_evlA(self, value): self.evlA.append(value)
    def insert_evlA_at(self, index, value): self.evlA.insert(index, value)
    def replace_evlA_at(self, index, value): self.evlA[index] = value
    def get_sub(self): return self.sub
    def set_sub(self, sub): self.sub = sub
    def add_sub(self, value): self.sub.append(value)
    def insert_sub_at(self, index, value): self.sub.insert(index, value)
    def replace_sub_at(self, index, value): self.sub[index] = value
    def hasContent_(self):
        if (
            self.ni is not None or
            self.hcl is not None or
            self.ch or
            self.memA or
            self.batA or
            self.aniA or
            self.andiA or
            self.fwrA or
            self.swrA or
            self.dviA or
            self.dvcA or
            self.rboA or
            self.evlA or
            self.sub
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='m2m:', name_='nodA', namespacedef_='xmlns:m2m="http://www.onem2m.org/xml/protocols"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='nodA')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='m2m:', name_='nodA', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='m2m:', name_='nodA'):
        pass
    def exportChildren(self, outfile, level, namespace_='m2m:', name_='nodA', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ni is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sni>%s</%sni>%s' % (namespace_, self.gds_format_string(quote_xml(self.ni).encode(ExternalEncoding), input_name='ni'), namespace_, eol_))
        if self.hcl is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%shcl>%s</%shcl>%s' % (namespace_, self.gds_format_string(quote_xml(self.hcl).encode(ExternalEncoding), input_name='hcl'), namespace_, eol_))
        for ch_ in self.ch:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sch>%s</%sch>%s' % (namespace_, self.gds_format_string(quote_xml(ch_).encode(ExternalEncoding), input_name='ch'), namespace_, eol_))
        for memA_ in self.memA:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smemA>%s</%smemA>%s' % (namespace_, self.gds_format_string(quote_xml(memA_).encode(ExternalEncoding), input_name='memA'), namespace_, eol_))
        for batA_ in self.batA:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbatA>%s</%sbatA>%s' % (namespace_, self.gds_format_string(quote_xml(batA_).encode(ExternalEncoding), input_name='batA'), namespace_, eol_))
        for aniA_ in self.aniA:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%saniA>%s</%saniA>%s' % (namespace_, self.gds_format_string(quote_xml(aniA_).encode(ExternalEncoding), input_name='aniA'), namespace_, eol_))
        for andiA_ in self.andiA:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sandiA>%s</%sandiA>%s' % (namespace_, self.gds_format_string(quote_xml(andiA_).encode(ExternalEncoding), input_name='andiA'), namespace_, eol_))
        for fwrA_ in self.fwrA:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfwrA>%s</%sfwrA>%s' % (namespace_, self.gds_format_string(quote_xml(fwrA_).encode(ExternalEncoding), input_name='fwrA'), namespace_, eol_))
        for swrA_ in self.swrA:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sswrA>%s</%sswrA>%s' % (namespace_, self.gds_format_string(quote_xml(swrA_).encode(ExternalEncoding), input_name='swrA'), namespace_, eol_))
        for dviA_ in self.dviA:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdviA>%s</%sdviA>%s' % (namespace_, self.gds_format_string(quote_xml(dviA_).encode(ExternalEncoding), input_name='dviA'), namespace_, eol_))
        for dvcA_ in self.dvcA:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdvcA>%s</%sdvcA>%s' % (namespace_, self.gds_format_string(quote_xml(dvcA_).encode(ExternalEncoding), input_name='dvcA'), namespace_, eol_))
        for rboA_ in self.rboA:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srboA>%s</%srboA>%s' % (namespace_, self.gds_format_string(quote_xml(rboA_).encode(ExternalEncoding), input_name='rboA'), namespace_, eol_))
        for evlA_ in self.evlA:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sevlA>%s</%sevlA>%s' % (namespace_, self.gds_format_string(quote_xml(evlA_).encode(ExternalEncoding), input_name='evlA'), namespace_, eol_))
        for sub_ in self.sub:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssub>%s</%ssub>%s' % (namespace_, self.gds_format_string(quote_xml(sub_).encode(ExternalEncoding), input_name='sub'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ni':
            ni_ = child_.text
            ni_ = self.gds_validate_string(ni_, node, 'ni')
            self.ni = ni_
        elif nodeName_ == 'hcl':
            hcl_ = child_.text
            hcl_ = self.gds_validate_string(hcl_, node, 'hcl')
            self.hcl = hcl_
        elif nodeName_ == 'ch':
            ch_ = child_.text
            ch_ = self.gds_validate_string(ch_, node, 'ch')
            self.ch.append(ch_)
        elif nodeName_ == 'memA':
            memA_ = child_.text
            memA_ = self.gds_validate_string(memA_, node, 'memA')
            self.memA.append(memA_)
        elif nodeName_ == 'batA':
            batA_ = child_.text
            batA_ = self.gds_validate_string(batA_, node, 'batA')
            self.batA.append(batA_)
        elif nodeName_ == 'aniA':
            aniA_ = child_.text
            aniA_ = self.gds_validate_string(aniA_, node, 'aniA')
            self.aniA.append(aniA_)
        elif nodeName_ == 'andiA':
            andiA_ = child_.text
            andiA_ = self.gds_validate_string(andiA_, node, 'andiA')
            self.andiA.append(andiA_)
        elif nodeName_ == 'fwrA':
            fwrA_ = child_.text
            fwrA_ = self.gds_validate_string(fwrA_, node, 'fwrA')
            self.fwrA.append(fwrA_)
        elif nodeName_ == 'swrA':
            swrA_ = child_.text
            swrA_ = self.gds_validate_string(swrA_, node, 'swrA')
            self.swrA.append(swrA_)
        elif nodeName_ == 'dviA':
            dviA_ = child_.text
            dviA_ = self.gds_validate_string(dviA_, node, 'dviA')
            self.dviA.append(dviA_)
        elif nodeName_ == 'dvcA':
            dvcA_ = child_.text
            dvcA_ = self.gds_validate_string(dvcA_, node, 'dvcA')
            self.dvcA.append(dvcA_)
        elif nodeName_ == 'rboA':
            rboA_ = child_.text
            rboA_ = self.gds_validate_string(rboA_, node, 'rboA')
            self.rboA.append(rboA_)
        elif nodeName_ == 'evlA':
            evlA_ = child_.text
            evlA_ = self.gds_validate_string(evlA_, node, 'evlA')
            self.evlA.append(evlA_)
        elif nodeName_ == 'sub':
            sub_ = child_.text
            sub_ = self.gds_validate_string(sub_, node, 'sub')
            self.sub.append(sub_)
        super(nodA, self).buildChildren(child_, node, nodeName_, True)
# end class nodA


GDSClassesMapping = {
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'nod'
        rootClass = nod
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='xmlns:m2m="http://www.onem2m.org/xml/protocols"',
            pretty_print=True)
    return rootObj


def parseEtree(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'nod'
        rootClass = nod
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(content)
        sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False):
    from StringIO import StringIO
    parser = None
    doc = parsexml_(StringIO(inString), parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'nod'
        rootClass = nod
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='xmlns:m2m="http://www.onem2m.org/xml/protocols"')
    return rootObj


def parseLiteral(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'nod'
        rootClass = nod
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('#from node import *\n\n')
        sys.stdout.write('import node as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "nod",
    "nodA"
]
