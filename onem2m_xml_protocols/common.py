#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Thu Jul 14 10:58:58 2016 by generateDS.py version 2.18a.
#
# Command line options:
#   ('-o', 'common.py')
#
# Command line arguments:
#   shortName-XSD-v2_3_0/CDT-commonTypes-v2_3_0.xsd
#
# Command line:
#   generateDS.py -o "common.py" shortName-XSD-v2_3_0/CDT-commonTypes-v2_3_0.xsd
#
# Current working directory (os.getcwd()):
#   generateDS-2.18a0
#

import sys
import json
import re as re_
import base64
import datetime as datetime_
import warnings as warnings_
from lxml import etree as etree_


Validate_simpletypes_ = True


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        parser = etree_.ETCompatXMLParser()
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError as exp:

    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return values
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_validate_float(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(
                        node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (time_parts[0], micro_seconds, )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.  We should:
            # - AND the outer elements
            # - OR the inner elements
            found1 = True
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    if re_.search(patterns2, target) is not None:
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.iteritems()))


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'ascii'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace, pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, namespace, name, pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name, base64.b64encode(self.value), self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0):
        self.name = name
        self.data_type = data_type
        self.container = container
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class deliveryMetaData(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, tcop=None, tcin=None):
        self.original_tagname_ = None
        self.tcop = tcop
        self.tcin = tcin
        self.validate_listOfM2MID(self.tcin)
    def factory(*args_, **kwargs_):
        if deliveryMetaData.subclass:
            return deliveryMetaData.subclass(*args_, **kwargs_)
        else:
            return deliveryMetaData(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_tcop(self): return self.tcop
    def set_tcop(self, tcop): self.tcop = tcop
    def get_tcin(self): return self.tcin
    def set_tcin(self, tcin): self.tcin = tcin
    def validate_listOfM2MID(self, value):
        # Validate type listOfM2MID, a restriction on m2m:ID.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on listOfM2MID' % {"value" : value} )
    def hasContent_(self):
        if (
            self.tcop is not None or
            self.tcin is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='m2m:', name_='deliveryMetaData', namespacedef_='xmlns:m2m="http://www.onem2m.org/xml/protocols"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='deliveryMetaData')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='m2m:', name_='deliveryMetaData', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='m2m:', name_='deliveryMetaData'):
        pass
    def exportChildren(self, outfile, level, namespace_='m2m:', name_='deliveryMetaData', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.tcop is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stcop>%s</%stcop>%s' % (namespace_, self.gds_format_boolean(self.tcop, input_name='tcop'), namespace_, eol_))
        if self.tcin is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stcin>%s</%stcin>%s' % (namespace_, self.gds_format_string(quote_xml(' '.join(self.tcin)).encode(ExternalEncoding), input_name='tcin'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'tcop':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'tcop')
            self.tcop = ival_
        elif nodeName_ == 'tcin':
            tcin_ = child_.text
            self.tcin = tcin_
            # validate type listOfM2MID
            self.validate_listOfM2MID(self.tcin)
# end class deliveryMetaData


class aggregatedRequest(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, req=None):
        self.original_tagname_ = None
        if req is None:
            self.req = []
        else:
            self.req = req
    def factory(*args_, **kwargs_):
        if aggregatedRequest.subclass:
            return aggregatedRequest.subclass(*args_, **kwargs_)
        else:
            return aggregatedRequest(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_req(self): return self.req
    def set_req(self, req): self.req = req
    def add_req(self, value): self.req.append(value)
    def insert_req_at(self, index, value): self.req.insert(index, value)
    def replace_req_at(self, index, value): self.req[index] = value
    def hasContent_(self):
        if (
            self.req
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='m2m:', name_='aggregatedRequest', namespacedef_='xmlns:m2m="http://www.onem2m.org/xml/protocols"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='aggregatedRequest')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='m2m:', name_='aggregatedRequest', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='m2m:', name_='aggregatedRequest'):
        pass
    def exportChildren(self, outfile, level, namespace_='m2m:', name_='aggregatedRequest', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for req_ in self.req:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sreq>%s</%sreq>%s' % (namespace_, self.gds_format_string(quote_xml(req_).encode(ExternalEncoding), input_name='req'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'req':
            req_ = child_.text
            req_ = self.gds_validate_string(req_, node, 'req')
            self.req.append(req_)
# end class aggregatedRequest


class metaInformation(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ty=None, nm=None, ot=None, rqet=None, rset=None, oet=None, rt=None, rp=None, rcn=None, ec=None, da=None, gid=None, fc=None, drt=None):
        self.original_tagname_ = None
        self.ty = ty
        self.nm = nm
        self.ot = ot
        self.validate_timestamp(self.ot)
        self.rqet = rqet
        self.validate_absRelTimestamp(self.rqet)
        self.rset = rset
        self.validate_absRelTimestamp(self.rset)
        self.oet = oet
        self.validate_absRelTimestamp(self.oet)
        self.rt = rt
        self.rp = rp
        self.validate_absRelTimestamp(self.rp)
        self.rcn = rcn
        self.ec = ec
        self.validate_eventCat(self.ec)
        self.da = da
        self.gid = gid
        self.fc = fc
        self.drt = drt
    def factory(*args_, **kwargs_):
        if metaInformation.subclass:
            return metaInformation.subclass(*args_, **kwargs_)
        else:
            return metaInformation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ty(self): return self.ty
    def set_ty(self, ty): self.ty = ty
    def get_nm(self): return self.nm
    def set_nm(self, nm): self.nm = nm
    def get_ot(self): return self.ot
    def set_ot(self, ot): self.ot = ot
    def get_rqet(self): return self.rqet
    def set_rqet(self, rqet): self.rqet = rqet
    def get_rset(self): return self.rset
    def set_rset(self, rset): self.rset = rset
    def get_oet(self): return self.oet
    def set_oet(self, oet): self.oet = oet
    def get_rt(self): return self.rt
    def set_rt(self, rt): self.rt = rt
    def get_rp(self): return self.rp
    def set_rp(self, rp): self.rp = rp
    def get_rcn(self): return self.rcn
    def set_rcn(self, rcn): self.rcn = rcn
    def get_ec(self): return self.ec
    def set_ec(self, ec): self.ec = ec
    def get_da(self): return self.da
    def set_da(self, da): self.da = da
    def get_gid(self): return self.gid
    def set_gid(self, gid): self.gid = gid
    def get_fc(self): return self.fc
    def set_fc(self, fc): self.fc = fc
    def get_drt(self): return self.drt
    def set_drt(self, drt): self.drt = drt
    def validate_timestamp(self, value):
        # Validate type timestamp, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_timestamp_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_timestamp_patterns_, ))
    validate_timestamp_patterns_ = [['^\\d{4}(0[1-9]|1[0-2])(0[1-9]|[1-2]\\d|30|31)T([01]\\d|2[0-3])[0-5]\\d[0-5]\\d(,\\d{1,6})?$']]
    def validate_absRelTimestamp(self, value):
        # Validate type absRelTimestamp, a restriction on xs:long.
        pass
    def validate_eventCat(self, value):
        # Validate type eventCat, a restriction on None.
        pass
    def hasContent_(self):
        if (
            self.ty is not None or
            self.nm is not None or
            self.ot is not None or
            self.rqet is not None or
            self.rset is not None or
            self.oet is not None or
            self.rt is not None or
            self.rp is not None or
            self.rcn is not None or
            self.ec is not None or
            self.da is not None or
            self.gid is not None or
            self.fc is not None or
            self.drt is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='m2m:', name_='metaInformation', namespacedef_='xmlns:m2m="http://www.onem2m.org/xml/protocols"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='metaInformation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='m2m:', name_='metaInformation', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='m2m:', name_='metaInformation'):
        pass
    def exportChildren(self, outfile, level, namespace_='m2m:', name_='metaInformation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ty is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sty>%s</%sty>%s' % (namespace_, self.gds_format_string(quote_xml(self.ty).encode(ExternalEncoding), input_name='ty'), namespace_, eol_))
        if self.nm is not None:
            self.nm.export(outfile, level, namespace_, name_='nm', pretty_print=pretty_print)
        if self.ot is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sot>%s</%sot>%s' % (namespace_, self.gds_format_string(quote_xml(self.ot).encode(ExternalEncoding), input_name='ot'), namespace_, eol_))
        if self.rqet is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srqet>%s</%srqet>%s' % (namespace_, self.gds_format_integer(self.rqet, input_name='rqet'), namespace_, eol_))
        if self.rset is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srset>%s</%srset>%s' % (namespace_, self.gds_format_integer(self.rset, input_name='rset'), namespace_, eol_))
        if self.oet is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%soet>%s</%soet>%s' % (namespace_, self.gds_format_integer(self.oet, input_name='oet'), namespace_, eol_))
        if self.rt is not None:
            self.rt.export(outfile, level, namespace_, name_='rt', pretty_print=pretty_print)
        if self.rp is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srp>%s</%srp>%s' % (namespace_, self.gds_format_integer(self.rp, input_name='rp'), namespace_, eol_))
        if self.rcn is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srcn>%s</%srcn>%s' % (namespace_, self.gds_format_string(quote_xml(self.rcn).encode(ExternalEncoding), input_name='rcn'), namespace_, eol_))
        if self.ec is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sec>%s</%sec>%s' % (namespace_, self.gds_format_string(quote_xml(self.ec).encode(ExternalEncoding), input_name='ec'), namespace_, eol_))
        if self.da is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sda>%s</%sda>%s' % (namespace_, self.gds_format_boolean(self.da, input_name='da'), namespace_, eol_))
        if self.gid is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sgid>%s</%sgid>%s' % (namespace_, self.gds_format_string(quote_xml(self.gid).encode(ExternalEncoding), input_name='gid'), namespace_, eol_))
        if self.fc is not None:
            self.fc.export(outfile, level, namespace_, name_='fc', pretty_print=pretty_print)
        if self.drt is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdrt>%s</%sdrt>%s' % (namespace_, self.gds_format_string(quote_xml(self.drt).encode(ExternalEncoding), input_name='drt'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ty':
            ty_ = child_.text
            ty_ = self.gds_validate_string(ty_, node, 'ty')
            self.ty = ty_
        elif nodeName_ == 'nm':
            obj_ = xs_NCName.factory()
            obj_.build(child_)
            self.nm = obj_
            obj_.original_tagname_ = 'nm'
        elif nodeName_ == 'ot':
            ot_ = child_.text
            ot_ = self.gds_validate_string(ot_, node, 'ot')
            self.ot = ot_
            # validate type timestamp
            self.validate_timestamp(self.ot)
        elif nodeName_ == 'rqet':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'rqet')
            self.rqet = ival_
            # validate type absRelTimestamp
            self.validate_absRelTimestamp(self.rqet)
        elif nodeName_ == 'rset':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'rset')
            self.rset = ival_
            # validate type absRelTimestamp
            self.validate_absRelTimestamp(self.rset)
        elif nodeName_ == 'oet':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'oet')
            self.oet = ival_
            # validate type absRelTimestamp
            self.validate_absRelTimestamp(self.oet)
        elif nodeName_ == 'rt':
            obj_ = responseTypeInfo.factory()
            obj_.build(child_)
            self.rt = obj_
            obj_.original_tagname_ = 'rt'
        elif nodeName_ == 'rp':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'rp')
            self.rp = ival_
            # validate type absRelTimestamp
            self.validate_absRelTimestamp(self.rp)
        elif nodeName_ == 'rcn':
            rcn_ = child_.text
            rcn_ = self.gds_validate_string(rcn_, node, 'rcn')
            self.rcn = rcn_
        elif nodeName_ == 'ec':
            ec_ = child_.text
            ec_ = self.gds_validate_string(ec_, node, 'ec')
            self.ec = ec_
            # validate type eventCat
            self.validate_eventCat(self.ec)
        elif nodeName_ == 'da':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'da')
            self.da = ival_
        elif nodeName_ == 'gid':
            gid_ = child_.text
            gid_ = self.gds_validate_string(gid_, node, 'gid')
            self.gid = gid_
        elif nodeName_ == 'fc':
            obj_ = filterCriteria.factory()
            obj_.build(child_)
            self.fc = obj_
            obj_.original_tagname_ = 'fc'
        elif nodeName_ == 'drt':
            drt_ = child_.text
            drt_ = self.gds_validate_string(drt_, node, 'drt')
            self.drt = drt_
# end class metaInformation


class primitiveContent(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, anytypeobjs_=None):
        self.original_tagname_ = None
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if primitiveContent.subclass:
            return primitiveContent.subclass(*args_, **kwargs_)
        else:
            return primitiveContent(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def hasContent_(self):
        if (
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='m2m:', name_='primitiveContent', namespacedef_='xmlns:m2m="http://www.onem2m.org/xml/protocols"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='primitiveContent')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='m2m:', name_='primitiveContent', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='m2m:', name_='primitiveContent'):
        pass
    def exportChildren(self, outfile, level, namespace_='m2m:', name_='primitiveContent', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        obj_ = self.gds_build_any(child_, 'primitiveContent')
        if obj_ is not None:
            self.add_anytypeobjs_(obj_)
# end class primitiveContent


class filterCriteria(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, crb=None, cra=None, ms=None, us=None, sts=None, stb=None, exb=None, exa=None, lbl=None, ty=None, sza=None, szb=None, cty=None, atr=None, fu=None, lim=None):
        self.original_tagname_ = None
        self.crb = crb
        self.validate_timestamp(self.crb)
        self.cra = cra
        self.validate_timestamp(self.cra)
        self.ms = ms
        self.validate_timestamp(self.ms)
        self.us = us
        self.validate_timestamp(self.us)
        self.sts = sts
        self.stb = stb
        self.exb = exb
        self.validate_timestamp(self.exb)
        self.exa = exa
        self.validate_timestamp(self.exa)
        self.lbl = lbl
        self.validate_labels(self.lbl)
        self.ty = ty
        self.sza = sza
        self.szb = szb
        if cty is None:
            self.cty = []
        else:
            self.cty = cty
        if atr is None:
            self.atr = []
        else:
            self.atr = atr
        self.fu = fu
        self.lim = lim
    def factory(*args_, **kwargs_):
        if filterCriteria.subclass:
            return filterCriteria.subclass(*args_, **kwargs_)
        else:
            return filterCriteria(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_crb(self): return self.crb
    def set_crb(self, crb): self.crb = crb
    def get_cra(self): return self.cra
    def set_cra(self, cra): self.cra = cra
    def get_ms(self): return self.ms
    def set_ms(self, ms): self.ms = ms
    def get_us(self): return self.us
    def set_us(self, us): self.us = us
    def get_sts(self): return self.sts
    def set_sts(self, sts): self.sts = sts
    def get_stb(self): return self.stb
    def set_stb(self, stb): self.stb = stb
    def get_exb(self): return self.exb
    def set_exb(self, exb): self.exb = exb
    def get_exa(self): return self.exa
    def set_exa(self, exa): self.exa = exa
    def get_lbl(self): return self.lbl
    def set_lbl(self, lbl): self.lbl = lbl
    def get_ty(self): return self.ty
    def set_ty(self, ty): self.ty = ty
    def get_sza(self): return self.sza
    def set_sza(self, sza): self.sza = sza
    def get_szb(self): return self.szb
    def set_szb(self, szb): self.szb = szb
    def get_cty(self): return self.cty
    def set_cty(self, cty): self.cty = cty
    def add_cty(self, value): self.cty.append(value)
    def insert_cty_at(self, index, value): self.cty.insert(index, value)
    def replace_cty_at(self, index, value): self.cty[index] = value
    def get_atr(self): return self.atr
    def set_atr(self, atr): self.atr = atr
    def add_atr(self, value): self.atr.append(value)
    def insert_atr_at(self, index, value): self.atr.insert(index, value)
    def replace_atr_at(self, index, value): self.atr[index] = value
    def get_fu(self): return self.fu
    def set_fu(self, fu): self.fu = fu
    def get_lim(self): return self.lim
    def set_lim(self, lim): self.lim = lim
    def validate_timestamp(self, value):
        # Validate type timestamp, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_timestamp_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_timestamp_patterns_, ))
    validate_timestamp_patterns_ = [['^\\d{4}(0[1-9]|1[0-2])(0[1-9]|[1-2]\\d|30|31)T([01]\\d|2[0-3])[0-5]\\d[0-5]\\d(,\\d{1,6})?$']]
    def validate_labels(self, value):
        # Validate type labels, a restriction on xs:token.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on labels' % {"value" : value} )
    def validate_typeOfContent(self, value):
        # Validate type typeOfContent, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_typeOfContent_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_typeOfContent_patterns_, ))
    validate_typeOfContent_patterns_ = [['^[\\w/!#$^_.+&\\-]+$']]
    def hasContent_(self):
        if (
            self.crb is not None or
            self.cra is not None or
            self.ms is not None or
            self.us is not None or
            self.sts is not None or
            self.stb is not None or
            self.exb is not None or
            self.exa is not None or
            self.lbl is not None or
            self.ty is not None or
            self.sza is not None or
            self.szb is not None or
            self.cty or
            self.atr or
            self.fu is not None or
            self.lim is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='m2m:', name_='filterCriteria', namespacedef_='xmlns:m2m="http://www.onem2m.org/xml/protocols"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='filterCriteria')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='m2m:', name_='filterCriteria', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='m2m:', name_='filterCriteria'):
        pass
    def exportChildren(self, outfile, level, namespace_='m2m:', name_='filterCriteria', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.crb is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scrb>%s</%scrb>%s' % (namespace_, self.gds_format_string(quote_xml(self.crb).encode(ExternalEncoding), input_name='crb'), namespace_, eol_))
        if self.cra is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scra>%s</%scra>%s' % (namespace_, self.gds_format_string(quote_xml(self.cra).encode(ExternalEncoding), input_name='cra'), namespace_, eol_))
        if self.ms is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sms>%s</%sms>%s' % (namespace_, self.gds_format_string(quote_xml(self.ms).encode(ExternalEncoding), input_name='ms'), namespace_, eol_))
        if self.us is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sus>%s</%sus>%s' % (namespace_, self.gds_format_string(quote_xml(self.us).encode(ExternalEncoding), input_name='us'), namespace_, eol_))
        if self.sts is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssts>%s</%ssts>%s' % (namespace_, self.gds_format_integer(self.sts, input_name='sts'), namespace_, eol_))
        if self.stb is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstb>%s</%sstb>%s' % (namespace_, self.gds_format_integer(self.stb, input_name='stb'), namespace_, eol_))
        if self.exb is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sexb>%s</%sexb>%s' % (namespace_, self.gds_format_string(quote_xml(self.exb).encode(ExternalEncoding), input_name='exb'), namespace_, eol_))
        if self.exa is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sexa>%s</%sexa>%s' % (namespace_, self.gds_format_string(quote_xml(self.exa).encode(ExternalEncoding), input_name='exa'), namespace_, eol_))
        if self.lbl is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slbl>%s</%slbl>%s' % (namespace_, self.gds_format_string(quote_xml(' '.join(self.lbl)).encode(ExternalEncoding), input_name='lbl'), namespace_, eol_))
        if self.ty is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sty>%s</%sty>%s' % (namespace_, self.gds_format_string(quote_xml(self.ty).encode(ExternalEncoding), input_name='ty'), namespace_, eol_))
        if self.sza is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssza>%s</%ssza>%s' % (namespace_, self.gds_format_integer(self.sza, input_name='sza'), namespace_, eol_))
        if self.szb is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sszb>%s</%sszb>%s' % (namespace_, self.gds_format_integer(self.szb, input_name='szb'), namespace_, eol_))
        for cty_ in self.cty:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scty>%s</%scty>%s' % (namespace_, self.gds_format_string(quote_xml(cty_).encode(ExternalEncoding), input_name='cty'), namespace_, eol_))
        for atr_ in self.atr:
            atr_.export(outfile, level, namespace_, name_='atr', pretty_print=pretty_print)
        if self.fu is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfu>%s</%sfu>%s' % (namespace_, self.gds_format_string(quote_xml(self.fu).encode(ExternalEncoding), input_name='fu'), namespace_, eol_))
        if self.lim is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slim>%s</%slim>%s' % (namespace_, self.gds_format_integer(self.lim, input_name='lim'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'crb':
            crb_ = child_.text
            crb_ = self.gds_validate_string(crb_, node, 'crb')
            self.crb = crb_
            # validate type timestamp
            self.validate_timestamp(self.crb)
        elif nodeName_ == 'cra':
            cra_ = child_.text
            cra_ = self.gds_validate_string(cra_, node, 'cra')
            self.cra = cra_
            # validate type timestamp
            self.validate_timestamp(self.cra)
        elif nodeName_ == 'ms':
            ms_ = child_.text
            ms_ = self.gds_validate_string(ms_, node, 'ms')
            self.ms = ms_
            # validate type timestamp
            self.validate_timestamp(self.ms)
        elif nodeName_ == 'us':
            us_ = child_.text
            us_ = self.gds_validate_string(us_, node, 'us')
            self.us = us_
            # validate type timestamp
            self.validate_timestamp(self.us)
        elif nodeName_ == 'sts':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'sts')
            self.sts = ival_
        elif nodeName_ == 'stb':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'stb')
            self.stb = ival_
        elif nodeName_ == 'exb':
            exb_ = child_.text
            exb_ = self.gds_validate_string(exb_, node, 'exb')
            self.exb = exb_
            # validate type timestamp
            self.validate_timestamp(self.exb)
        elif nodeName_ == 'exa':
            exa_ = child_.text
            exa_ = self.gds_validate_string(exa_, node, 'exa')
            self.exa = exa_
            # validate type timestamp
            self.validate_timestamp(self.exa)
        elif nodeName_ == 'lbl':
            lbl_ = child_.text
            lbl_ = re_.sub(String_cleanup_pat_, " ", lbl_).strip()
            self.lbl = lbl_
            # validate type labels
            self.validate_labels(self.lbl)
        elif nodeName_ == 'ty':
            ty_ = child_.text
            ty_ = self.gds_validate_string(ty_, node, 'ty')
            self.ty = ty_
        elif nodeName_ == 'sza':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'sza')
            self.sza = ival_
        elif nodeName_ == 'szb':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'szb')
            self.szb = ival_
        elif nodeName_ == 'cty':
            cty_ = child_.text
            cty_ = self.gds_validate_string(cty_, node, 'cty')
            self.cty.append(cty_)
            # validate type typeOfContent
            self.validate_typeOfContent(self.cty[-1])
        elif nodeName_ == 'atr':
            obj_ = attribute.factory()
            obj_.build(child_)
            self.atr.append(obj_)
            obj_.original_tagname_ = 'atr'
        elif nodeName_ == 'fu':
            fu_ = child_.text
            fu_ = self.gds_validate_string(fu_, node, 'fu')
            self.fu = fu_
        elif nodeName_ == 'lim':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'lim')
            self.lim = ival_
# end class filterCriteria


class attribute(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nm=None, val=None):
        self.original_tagname_ = None
        self.nm = nm
        self.val = val
    def factory(*args_, **kwargs_):
        if attribute.subclass:
            return attribute.subclass(*args_, **kwargs_)
        else:
            return attribute(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_nm(self): return self.nm
    def set_nm(self, nm): self.nm = nm
    def get_val(self): return self.val
    def set_val(self, val): self.val = val
    def hasContent_(self):
        if (
            self.nm is not None or
            self.val is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='m2m:', name_='attribute', namespacedef_='xmlns:m2m="http://www.onem2m.org/xml/protocols"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='attribute')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='m2m:', name_='attribute', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='m2m:', name_='attribute'):
        pass
    def exportChildren(self, outfile, level, namespace_='m2m:', name_='attribute', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.nm is not None:
            self.nm.export(outfile, level, namespace_, name_='nm', pretty_print=pretty_print)
        if self.val is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sval>%s</%sval>%s' % (namespace_, self.gds_format_string(quote_xml(self.val).encode(ExternalEncoding), input_name='val'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'nm':
            obj_ = xs_NCName.factory()
            obj_.build(child_)
            self.nm = obj_
            obj_.original_tagname_ = 'nm'
        elif nodeName_ == 'val':
            val_ = child_.text
            val_ = self.gds_validate_string(val_, node, 'val')
            self.val = val_
# end class attribute


class scheduleEntries(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, sce=None):
        self.original_tagname_ = None
        if sce is None:
            self.sce = []
        else:
            self.sce = sce
    def factory(*args_, **kwargs_):
        if scheduleEntries.subclass:
            return scheduleEntries.subclass(*args_, **kwargs_)
        else:
            return scheduleEntries(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_sce(self): return self.sce
    def set_sce(self, sce): self.sce = sce
    def add_sce(self, value): self.sce.append(value)
    def insert_sce_at(self, index, value): self.sce.insert(index, value)
    def replace_sce_at(self, index, value): self.sce[index] = value
    def validate_scheduleEntry(self, value):
        # Validate type scheduleEntry, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_scheduleEntry_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_scheduleEntry_patterns_, ))
    validate_scheduleEntry_patterns_ = [['^(([*]|[1-5]?\\d([,-/][1-5]?\\d)*)\\s+){2}([*]|((1?\\d|2[0-3])([,-/](1?\\d|2[0-3]))*))\\s+([*]|(([1-9]|1\\d|2\\d|3[01])([,-/]([1-9]|1\\d|2\\d|3[01]))*))\\s+([*]|(([1-9]|1[0-2])([,-/]([1-9]|1[0-2]))*))\\s+([*]|([0-6]([,-/][0-6])*))\\s+([*]|([2-9]\\d\\d\\d)(([,-]([2-9]\\d\\d\\d)([/][\\d]?[\\d]?[\\d]?[\\d])?)*))$']]
    def hasContent_(self):
        if (
            self.sce
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='m2m:', name_='scheduleEntries', namespacedef_='xmlns:m2m="http://www.onem2m.org/xml/protocols"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='scheduleEntries')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='m2m:', name_='scheduleEntries', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='m2m:', name_='scheduleEntries'):
        pass
    def exportChildren(self, outfile, level, namespace_='m2m:', name_='scheduleEntries', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for sce_ in self.sce:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssce>%s</%ssce>%s' % (namespace_, self.gds_format_string(quote_xml(sce_).encode(ExternalEncoding), input_name='sce'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'sce':
            sce_ = child_.text
            sce_ = self.gds_validate_string(sce_, node, 'sce')
            self.sce.append(sce_)
            # validate type scheduleEntry
            self.validate_scheduleEntry(self.sce[-1])
# end class scheduleEntries


class actionStatus(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, acn=None, sus=None):
        self.original_tagname_ = None
        self.acn = acn
        self.sus = sus
    def factory(*args_, **kwargs_):
        if actionStatus.subclass:
            return actionStatus.subclass(*args_, **kwargs_)
        else:
            return actionStatus(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_acn(self): return self.acn
    def set_acn(self, acn): self.acn = acn
    def get_sus(self): return self.sus
    def set_sus(self, sus): self.sus = sus
    def hasContent_(self):
        if (
            self.acn is not None or
            self.sus is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='m2m:', name_='actionStatus', namespacedef_='xmlns:m2m="http://www.onem2m.org/xml/protocols"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='actionStatus')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='m2m:', name_='actionStatus', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='m2m:', name_='actionStatus'):
        pass
    def exportChildren(self, outfile, level, namespace_='m2m:', name_='actionStatus', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.acn is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sacn>%s</%sacn>%s' % (namespace_, self.gds_format_string(quote_xml(self.acn).encode(ExternalEncoding), input_name='acn'), namespace_, eol_))
        if self.sus is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssus>%s</%ssus>%s' % (namespace_, self.gds_format_string(quote_xml(self.sus).encode(ExternalEncoding), input_name='sus'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'acn':
            acn_ = child_.text
            acn_ = self.gds_validate_string(acn_, node, 'acn')
            self.acn = acn_
        elif nodeName_ == 'sus':
            sus_ = child_.text
            sus_ = self.gds_validate_string(sus_, node, 'sus')
            self.sus = sus_
# end class actionStatus


class anyArgType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nm=None, val=None):
        self.original_tagname_ = None
        self.nm = nm
        self.val = val
    def factory(*args_, **kwargs_):
        if anyArgType.subclass:
            return anyArgType.subclass(*args_, **kwargs_)
        else:
            return anyArgType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_nm(self): return self.nm
    def set_nm(self, nm): self.nm = nm
    def get_val(self): return self.val
    def set_val(self, val): self.val = val
    def hasContent_(self):
        if (
            self.nm is not None or
            self.val is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='m2m:', name_='anyArgType', namespacedef_='xmlns:m2m="http://www.onem2m.org/xml/protocols"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='anyArgType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='m2m:', name_='anyArgType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='m2m:', name_='anyArgType'):
        pass
    def exportChildren(self, outfile, level, namespace_='m2m:', name_='anyArgType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.nm is not None:
            self.nm.export(outfile, level, namespace_, name_='nm', pretty_print=pretty_print)
        if self.val is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sval>%s</%sval>%s' % (namespace_, self.gds_format_string(quote_xml(self.val).encode(ExternalEncoding), input_name='val'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'nm':
            obj_ = xs_NCName.factory()
            obj_.build(child_)
            self.nm = obj_
            obj_.original_tagname_ = 'nm'
        elif nodeName_ == 'val':
            val_ = child_.text
            val_ = self.gds_validate_string(val_, node, 'val')
            self.val = val_
# end class anyArgType


class resetArgsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, any=None):
        self.original_tagname_ = None
        if any is None:
            self.any = []
        else:
            self.any = any
    def factory(*args_, **kwargs_):
        if resetArgsType.subclass:
            return resetArgsType.subclass(*args_, **kwargs_)
        else:
            return resetArgsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_any(self): return self.any
    def set_any(self, any): self.any = any
    def add_any(self, value): self.any.append(value)
    def insert_any_at(self, index, value): self.any.insert(index, value)
    def replace_any_at(self, index, value): self.any[index] = value
    def hasContent_(self):
        if (
            self.any
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='m2m:', name_='resetArgsType', namespacedef_='xmlns:m2m="http://www.onem2m.org/xml/protocols"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='resetArgsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='m2m:', name_='resetArgsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='m2m:', name_='resetArgsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='m2m:', name_='resetArgsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for any_ in self.any:
            any_.export(outfile, level, namespace_, name_='any', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'any':
            obj_ = anyArgType.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'any'
# end class resetArgsType


class rebootArgsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, any=None):
        self.original_tagname_ = None
        if any is None:
            self.any = []
        else:
            self.any = any
    def factory(*args_, **kwargs_):
        if rebootArgsType.subclass:
            return rebootArgsType.subclass(*args_, **kwargs_)
        else:
            return rebootArgsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_any(self): return self.any
    def set_any(self, any): self.any = any
    def add_any(self, value): self.any.append(value)
    def insert_any_at(self, index, value): self.any.insert(index, value)
    def replace_any_at(self, index, value): self.any[index] = value
    def hasContent_(self):
        if (
            self.any
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='m2m:', name_='rebootArgsType', namespacedef_='xmlns:m2m="http://www.onem2m.org/xml/protocols"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='rebootArgsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='m2m:', name_='rebootArgsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='m2m:', name_='rebootArgsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='m2m:', name_='rebootArgsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for any_ in self.any:
            any_.export(outfile, level, namespace_, name_='any', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'any':
            obj_ = anyArgType.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'any'
# end class rebootArgsType


class uploadArgsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ftyp=None, url=None, unm=None, pwd=None, any=None):
        self.original_tagname_ = None
        self.ftyp = ftyp
        self.url = url
        self.unm = unm
        self.pwd = pwd
        if any is None:
            self.any = []
        else:
            self.any = any
    def factory(*args_, **kwargs_):
        if uploadArgsType.subclass:
            return uploadArgsType.subclass(*args_, **kwargs_)
        else:
            return uploadArgsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ftyp(self): return self.ftyp
    def set_ftyp(self, ftyp): self.ftyp = ftyp
    def get_url(self): return self.url
    def set_url(self, url): self.url = url
    def get_unm(self): return self.unm
    def set_unm(self, unm): self.unm = unm
    def get_pwd(self): return self.pwd
    def set_pwd(self, pwd): self.pwd = pwd
    def get_any(self): return self.any
    def set_any(self, any): self.any = any
    def add_any(self, value): self.any.append(value)
    def insert_any_at(self, index, value): self.any.insert(index, value)
    def replace_any_at(self, index, value): self.any[index] = value
    def hasContent_(self):
        if (
            self.ftyp is not None or
            self.url is not None or
            self.unm is not None or
            self.pwd is not None or
            self.any
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='m2m:', name_='uploadArgsType', namespacedef_='xmlns:m2m="http://www.onem2m.org/xml/protocols"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='uploadArgsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='m2m:', name_='uploadArgsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='m2m:', name_='uploadArgsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='m2m:', name_='uploadArgsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ftyp is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sftyp>%s</%sftyp>%s' % (namespace_, self.gds_format_string(quote_xml(self.ftyp).encode(ExternalEncoding), input_name='ftyp'), namespace_, eol_))
        if self.url is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%surl>%s</%surl>%s' % (namespace_, self.gds_format_string(quote_xml(self.url).encode(ExternalEncoding), input_name='url'), namespace_, eol_))
        if self.unm is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sunm>%s</%sunm>%s' % (namespace_, self.gds_format_string(quote_xml(self.unm).encode(ExternalEncoding), input_name='unm'), namespace_, eol_))
        if self.pwd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spwd>%s</%spwd>%s' % (namespace_, self.gds_format_string(quote_xml(self.pwd).encode(ExternalEncoding), input_name='pwd'), namespace_, eol_))
        for any_ in self.any:
            any_.export(outfile, level, namespace_, name_='any', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ftyp':
            ftyp_ = child_.text
            ftyp_ = self.gds_validate_string(ftyp_, node, 'ftyp')
            self.ftyp = ftyp_
        elif nodeName_ == 'url':
            url_ = child_.text
            url_ = self.gds_validate_string(url_, node, 'url')
            self.url = url_
        elif nodeName_ == 'unm':
            unm_ = child_.text
            unm_ = self.gds_validate_string(unm_, node, 'unm')
            self.unm = unm_
        elif nodeName_ == 'pwd':
            pwd_ = child_.text
            pwd_ = self.gds_validate_string(pwd_, node, 'pwd')
            self.pwd = pwd_
        elif nodeName_ == 'any':
            obj_ = anyArgType.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'any'
# end class uploadArgsType


class downloadArgsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ftyp=None, url=None, unm=None, pwd=None, fsi=None, tgf=None, dss=None, surl=None, stt=None, cpt=None, any=None):
        self.original_tagname_ = None
        self.ftyp = ftyp
        self.url = url
        self.unm = unm
        self.pwd = pwd
        self.fsi = fsi
        self.tgf = tgf
        self.dss = dss
        self.surl = surl
        self.stt = stt
        self.validate_timestamp(self.stt)
        self.cpt = cpt
        self.validate_timestamp(self.cpt)
        if any is None:
            self.any = []
        else:
            self.any = any
    def factory(*args_, **kwargs_):
        if downloadArgsType.subclass:
            return downloadArgsType.subclass(*args_, **kwargs_)
        else:
            return downloadArgsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ftyp(self): return self.ftyp
    def set_ftyp(self, ftyp): self.ftyp = ftyp
    def get_url(self): return self.url
    def set_url(self, url): self.url = url
    def get_unm(self): return self.unm
    def set_unm(self, unm): self.unm = unm
    def get_pwd(self): return self.pwd
    def set_pwd(self, pwd): self.pwd = pwd
    def get_fsi(self): return self.fsi
    def set_fsi(self, fsi): self.fsi = fsi
    def get_tgf(self): return self.tgf
    def set_tgf(self, tgf): self.tgf = tgf
    def get_dss(self): return self.dss
    def set_dss(self, dss): self.dss = dss
    def get_surl(self): return self.surl
    def set_surl(self, surl): self.surl = surl
    def get_stt(self): return self.stt
    def set_stt(self, stt): self.stt = stt
    def get_cpt(self): return self.cpt
    def set_cpt(self, cpt): self.cpt = cpt
    def get_any(self): return self.any
    def set_any(self, any): self.any = any
    def add_any(self, value): self.any.append(value)
    def insert_any_at(self, index, value): self.any.insert(index, value)
    def replace_any_at(self, index, value): self.any[index] = value
    def validate_timestamp(self, value):
        # Validate type timestamp, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_timestamp_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_timestamp_patterns_, ))
    validate_timestamp_patterns_ = [['^\\d{4}(0[1-9]|1[0-2])(0[1-9]|[1-2]\\d|30|31)T([01]\\d|2[0-3])[0-5]\\d[0-5]\\d(,\\d{1,6})?$']]
    def hasContent_(self):
        if (
            self.ftyp is not None or
            self.url is not None or
            self.unm is not None or
            self.pwd is not None or
            self.fsi is not None or
            self.tgf is not None or
            self.dss is not None or
            self.surl is not None or
            self.stt is not None or
            self.cpt is not None or
            self.any
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='m2m:', name_='downloadArgsType', namespacedef_='xmlns:m2m="http://www.onem2m.org/xml/protocols"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='downloadArgsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='m2m:', name_='downloadArgsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='m2m:', name_='downloadArgsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='m2m:', name_='downloadArgsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ftyp is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sftyp>%s</%sftyp>%s' % (namespace_, self.gds_format_string(quote_xml(self.ftyp).encode(ExternalEncoding), input_name='ftyp'), namespace_, eol_))
        if self.url is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%surl>%s</%surl>%s' % (namespace_, self.gds_format_string(quote_xml(self.url).encode(ExternalEncoding), input_name='url'), namespace_, eol_))
        if self.unm is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sunm>%s</%sunm>%s' % (namespace_, self.gds_format_string(quote_xml(self.unm).encode(ExternalEncoding), input_name='unm'), namespace_, eol_))
        if self.pwd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spwd>%s</%spwd>%s' % (namespace_, self.gds_format_string(quote_xml(self.pwd).encode(ExternalEncoding), input_name='pwd'), namespace_, eol_))
        if self.fsi is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfsi>%s</%sfsi>%s' % (namespace_, self.gds_format_integer(self.fsi, input_name='fsi'), namespace_, eol_))
        if self.tgf is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stgf>%s</%stgf>%s' % (namespace_, self.gds_format_string(quote_xml(self.tgf).encode(ExternalEncoding), input_name='tgf'), namespace_, eol_))
        if self.dss is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdss>%s</%sdss>%s' % (namespace_, self.gds_format_integer(self.dss, input_name='dss'), namespace_, eol_))
        if self.surl is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssurl>%s</%ssurl>%s' % (namespace_, self.gds_format_string(quote_xml(self.surl).encode(ExternalEncoding), input_name='surl'), namespace_, eol_))
        if self.stt is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstt>%s</%sstt>%s' % (namespace_, self.gds_format_string(quote_xml(self.stt).encode(ExternalEncoding), input_name='stt'), namespace_, eol_))
        if self.cpt is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scpt>%s</%scpt>%s' % (namespace_, self.gds_format_string(quote_xml(self.cpt).encode(ExternalEncoding), input_name='cpt'), namespace_, eol_))
        for any_ in self.any:
            any_.export(outfile, level, namespace_, name_='any', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ftyp':
            ftyp_ = child_.text
            ftyp_ = self.gds_validate_string(ftyp_, node, 'ftyp')
            self.ftyp = ftyp_
        elif nodeName_ == 'url':
            url_ = child_.text
            url_ = self.gds_validate_string(url_, node, 'url')
            self.url = url_
        elif nodeName_ == 'unm':
            unm_ = child_.text
            unm_ = self.gds_validate_string(unm_, node, 'unm')
            self.unm = unm_
        elif nodeName_ == 'pwd':
            pwd_ = child_.text
            pwd_ = self.gds_validate_string(pwd_, node, 'pwd')
            self.pwd = pwd_
        elif nodeName_ == 'fsi':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'fsi')
            self.fsi = ival_
        elif nodeName_ == 'tgf':
            tgf_ = child_.text
            tgf_ = self.gds_validate_string(tgf_, node, 'tgf')
            self.tgf = tgf_
        elif nodeName_ == 'dss':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'dss')
            self.dss = ival_
        elif nodeName_ == 'surl':
            surl_ = child_.text
            surl_ = self.gds_validate_string(surl_, node, 'surl')
            self.surl = surl_
        elif nodeName_ == 'stt':
            stt_ = child_.text
            stt_ = self.gds_validate_string(stt_, node, 'stt')
            self.stt = stt_
            # validate type timestamp
            self.validate_timestamp(self.stt)
        elif nodeName_ == 'cpt':
            cpt_ = child_.text
            cpt_ = self.gds_validate_string(cpt_, node, 'cpt')
            self.cpt = cpt_
            # validate type timestamp
            self.validate_timestamp(self.cpt)
        elif nodeName_ == 'any':
            obj_ = anyArgType.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'any'
# end class downloadArgsType


class softwareInstallArgsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, url=None, uuid=None, unm=None, pwd=None, eer=None, any=None):
        self.original_tagname_ = None
        self.url = url
        self.uuid = uuid
        self.unm = unm
        self.pwd = pwd
        self.eer = eer
        if any is None:
            self.any = []
        else:
            self.any = any
    def factory(*args_, **kwargs_):
        if softwareInstallArgsType.subclass:
            return softwareInstallArgsType.subclass(*args_, **kwargs_)
        else:
            return softwareInstallArgsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_url(self): return self.url
    def set_url(self, url): self.url = url
    def get_uuid(self): return self.uuid
    def set_uuid(self, uuid): self.uuid = uuid
    def get_unm(self): return self.unm
    def set_unm(self, unm): self.unm = unm
    def get_pwd(self): return self.pwd
    def set_pwd(self, pwd): self.pwd = pwd
    def get_eer(self): return self.eer
    def set_eer(self, eer): self.eer = eer
    def get_any(self): return self.any
    def set_any(self, any): self.any = any
    def add_any(self, value): self.any.append(value)
    def insert_any_at(self, index, value): self.any.insert(index, value)
    def replace_any_at(self, index, value): self.any[index] = value
    def hasContent_(self):
        if (
            self.url is not None or
            self.uuid is not None or
            self.unm is not None or
            self.pwd is not None or
            self.eer is not None or
            self.any
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='m2m:', name_='softwareInstallArgsType', namespacedef_='xmlns:m2m="http://www.onem2m.org/xml/protocols"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='softwareInstallArgsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='m2m:', name_='softwareInstallArgsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='m2m:', name_='softwareInstallArgsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='m2m:', name_='softwareInstallArgsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.url is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%surl>%s</%surl>%s' % (namespace_, self.gds_format_string(quote_xml(self.url).encode(ExternalEncoding), input_name='url'), namespace_, eol_))
        if self.uuid is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%suuid>%s</%suuid>%s' % (namespace_, self.gds_format_string(quote_xml(self.uuid).encode(ExternalEncoding), input_name='uuid'), namespace_, eol_))
        if self.unm is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sunm>%s</%sunm>%s' % (namespace_, self.gds_format_string(quote_xml(self.unm).encode(ExternalEncoding), input_name='unm'), namespace_, eol_))
        if self.pwd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spwd>%s</%spwd>%s' % (namespace_, self.gds_format_string(quote_xml(self.pwd).encode(ExternalEncoding), input_name='pwd'), namespace_, eol_))
        if self.eer is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%seer>%s</%seer>%s' % (namespace_, self.gds_format_string(quote_xml(self.eer).encode(ExternalEncoding), input_name='eer'), namespace_, eol_))
        for any_ in self.any:
            any_.export(outfile, level, namespace_, name_='any', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'url':
            url_ = child_.text
            url_ = self.gds_validate_string(url_, node, 'url')
            self.url = url_
        elif nodeName_ == 'uuid':
            uuid_ = child_.text
            uuid_ = self.gds_validate_string(uuid_, node, 'uuid')
            self.uuid = uuid_
        elif nodeName_ == 'unm':
            unm_ = child_.text
            unm_ = self.gds_validate_string(unm_, node, 'unm')
            self.unm = unm_
        elif nodeName_ == 'pwd':
            pwd_ = child_.text
            pwd_ = self.gds_validate_string(pwd_, node, 'pwd')
            self.pwd = pwd_
        elif nodeName_ == 'eer':
            eer_ = child_.text
            eer_ = self.gds_validate_string(eer_, node, 'eer')
            self.eer = eer_
        elif nodeName_ == 'any':
            obj_ = anyArgType.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'any'
# end class softwareInstallArgsType


class softwareUpdateArgsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uuid=None, vr=None, url=None, unm=None, pwd=None, eer=None, any=None):
        self.original_tagname_ = None
        self.uuid = uuid
        self.vr = vr
        self.url = url
        self.unm = unm
        self.pwd = pwd
        self.eer = eer
        if any is None:
            self.any = []
        else:
            self.any = any
    def factory(*args_, **kwargs_):
        if softwareUpdateArgsType.subclass:
            return softwareUpdateArgsType.subclass(*args_, **kwargs_)
        else:
            return softwareUpdateArgsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uuid(self): return self.uuid
    def set_uuid(self, uuid): self.uuid = uuid
    def get_vr(self): return self.vr
    def set_vr(self, vr): self.vr = vr
    def get_url(self): return self.url
    def set_url(self, url): self.url = url
    def get_unm(self): return self.unm
    def set_unm(self, unm): self.unm = unm
    def get_pwd(self): return self.pwd
    def set_pwd(self, pwd): self.pwd = pwd
    def get_eer(self): return self.eer
    def set_eer(self, eer): self.eer = eer
    def get_any(self): return self.any
    def set_any(self, any): self.any = any
    def add_any(self, value): self.any.append(value)
    def insert_any_at(self, index, value): self.any.insert(index, value)
    def replace_any_at(self, index, value): self.any[index] = value
    def hasContent_(self):
        if (
            self.uuid is not None or
            self.vr is not None or
            self.url is not None or
            self.unm is not None or
            self.pwd is not None or
            self.eer is not None or
            self.any
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='m2m:', name_='softwareUpdateArgsType', namespacedef_='xmlns:m2m="http://www.onem2m.org/xml/protocols"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='softwareUpdateArgsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='m2m:', name_='softwareUpdateArgsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='m2m:', name_='softwareUpdateArgsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='m2m:', name_='softwareUpdateArgsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.uuid is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%suuid>%s</%suuid>%s' % (namespace_, self.gds_format_string(quote_xml(self.uuid).encode(ExternalEncoding), input_name='uuid'), namespace_, eol_))
        if self.vr is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svr>%s</%svr>%s' % (namespace_, self.gds_format_string(quote_xml(self.vr).encode(ExternalEncoding), input_name='vr'), namespace_, eol_))
        if self.url is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%surl>%s</%surl>%s' % (namespace_, self.gds_format_string(quote_xml(self.url).encode(ExternalEncoding), input_name='url'), namespace_, eol_))
        if self.unm is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sunm>%s</%sunm>%s' % (namespace_, self.gds_format_string(quote_xml(self.unm).encode(ExternalEncoding), input_name='unm'), namespace_, eol_))
        if self.pwd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spwd>%s</%spwd>%s' % (namespace_, self.gds_format_string(quote_xml(self.pwd).encode(ExternalEncoding), input_name='pwd'), namespace_, eol_))
        if self.eer is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%seer>%s</%seer>%s' % (namespace_, self.gds_format_string(quote_xml(self.eer).encode(ExternalEncoding), input_name='eer'), namespace_, eol_))
        for any_ in self.any:
            any_.export(outfile, level, namespace_, name_='any', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'uuid':
            uuid_ = child_.text
            uuid_ = self.gds_validate_string(uuid_, node, 'uuid')
            self.uuid = uuid_
        elif nodeName_ == 'vr':
            vr_ = child_.text
            vr_ = self.gds_validate_string(vr_, node, 'vr')
            self.vr = vr_
        elif nodeName_ == 'url':
            url_ = child_.text
            url_ = self.gds_validate_string(url_, node, 'url')
            self.url = url_
        elif nodeName_ == 'unm':
            unm_ = child_.text
            unm_ = self.gds_validate_string(unm_, node, 'unm')
            self.unm = unm_
        elif nodeName_ == 'pwd':
            pwd_ = child_.text
            pwd_ = self.gds_validate_string(pwd_, node, 'pwd')
            self.pwd = pwd_
        elif nodeName_ == 'eer':
            eer_ = child_.text
            eer_ = self.gds_validate_string(eer_, node, 'eer')
            self.eer = eer_
        elif nodeName_ == 'any':
            obj_ = anyArgType.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'any'
# end class softwareUpdateArgsType


class softwareUninstallArgsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uuid=None, vr=None, eer=None, any=None):
        self.original_tagname_ = None
        self.uuid = uuid
        self.vr = vr
        self.eer = eer
        if any is None:
            self.any = []
        else:
            self.any = any
    def factory(*args_, **kwargs_):
        if softwareUninstallArgsType.subclass:
            return softwareUninstallArgsType.subclass(*args_, **kwargs_)
        else:
            return softwareUninstallArgsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uuid(self): return self.uuid
    def set_uuid(self, uuid): self.uuid = uuid
    def get_vr(self): return self.vr
    def set_vr(self, vr): self.vr = vr
    def get_eer(self): return self.eer
    def set_eer(self, eer): self.eer = eer
    def get_any(self): return self.any
    def set_any(self, any): self.any = any
    def add_any(self, value): self.any.append(value)
    def insert_any_at(self, index, value): self.any.insert(index, value)
    def replace_any_at(self, index, value): self.any[index] = value
    def hasContent_(self):
        if (
            self.uuid is not None or
            self.vr is not None or
            self.eer is not None or
            self.any
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='m2m:', name_='softwareUninstallArgsType', namespacedef_='xmlns:m2m="http://www.onem2m.org/xml/protocols"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='softwareUninstallArgsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='m2m:', name_='softwareUninstallArgsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='m2m:', name_='softwareUninstallArgsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='m2m:', name_='softwareUninstallArgsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.uuid is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%suuid>%s</%suuid>%s' % (namespace_, self.gds_format_string(quote_xml(self.uuid).encode(ExternalEncoding), input_name='uuid'), namespace_, eol_))
        if self.vr is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svr>%s</%svr>%s' % (namespace_, self.gds_format_string(quote_xml(self.vr).encode(ExternalEncoding), input_name='vr'), namespace_, eol_))
        if self.eer is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%seer>%s</%seer>%s' % (namespace_, self.gds_format_string(quote_xml(self.eer).encode(ExternalEncoding), input_name='eer'), namespace_, eol_))
        for any_ in self.any:
            any_.export(outfile, level, namespace_, name_='any', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'uuid':
            uuid_ = child_.text
            uuid_ = self.gds_validate_string(uuid_, node, 'uuid')
            self.uuid = uuid_
        elif nodeName_ == 'vr':
            vr_ = child_.text
            vr_ = self.gds_validate_string(vr_, node, 'vr')
            self.vr = vr_
        elif nodeName_ == 'eer':
            eer_ = child_.text
            eer_ = self.gds_validate_string(eer_, node, 'eer')
            self.eer = eer_
        elif nodeName_ == 'any':
            obj_ = anyArgType.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'any'
# end class softwareUninstallArgsType


class execReqArgsListType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, rst=None, rbo=None, uld=None, dld=None, swin=None, swup=None, swun=None):
        self.original_tagname_ = None
        if rst is None:
            self.rst = []
        else:
            self.rst = rst
        if rbo is None:
            self.rbo = []
        else:
            self.rbo = rbo
        if uld is None:
            self.uld = []
        else:
            self.uld = uld
        if dld is None:
            self.dld = []
        else:
            self.dld = dld
        if swin is None:
            self.swin = []
        else:
            self.swin = swin
        if swup is None:
            self.swup = []
        else:
            self.swup = swup
        if swun is None:
            self.swun = []
        else:
            self.swun = swun
    def factory(*args_, **kwargs_):
        if execReqArgsListType.subclass:
            return execReqArgsListType.subclass(*args_, **kwargs_)
        else:
            return execReqArgsListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_rst(self): return self.rst
    def set_rst(self, rst): self.rst = rst
    def add_rst(self, value): self.rst.append(value)
    def insert_rst_at(self, index, value): self.rst.insert(index, value)
    def replace_rst_at(self, index, value): self.rst[index] = value
    def get_rbo(self): return self.rbo
    def set_rbo(self, rbo): self.rbo = rbo
    def add_rbo(self, value): self.rbo.append(value)
    def insert_rbo_at(self, index, value): self.rbo.insert(index, value)
    def replace_rbo_at(self, index, value): self.rbo[index] = value
    def get_uld(self): return self.uld
    def set_uld(self, uld): self.uld = uld
    def add_uld(self, value): self.uld.append(value)
    def insert_uld_at(self, index, value): self.uld.insert(index, value)
    def replace_uld_at(self, index, value): self.uld[index] = value
    def get_dld(self): return self.dld
    def set_dld(self, dld): self.dld = dld
    def add_dld(self, value): self.dld.append(value)
    def insert_dld_at(self, index, value): self.dld.insert(index, value)
    def replace_dld_at(self, index, value): self.dld[index] = value
    def get_swin(self): return self.swin
    def set_swin(self, swin): self.swin = swin
    def add_swin(self, value): self.swin.append(value)
    def insert_swin_at(self, index, value): self.swin.insert(index, value)
    def replace_swin_at(self, index, value): self.swin[index] = value
    def get_swup(self): return self.swup
    def set_swup(self, swup): self.swup = swup
    def add_swup(self, value): self.swup.append(value)
    def insert_swup_at(self, index, value): self.swup.insert(index, value)
    def replace_swup_at(self, index, value): self.swup[index] = value
    def get_swun(self): return self.swun
    def set_swun(self, swun): self.swun = swun
    def add_swun(self, value): self.swun.append(value)
    def insert_swun_at(self, index, value): self.swun.insert(index, value)
    def replace_swun_at(self, index, value): self.swun[index] = value
    def hasContent_(self):
        if (
            self.rst or
            self.rbo or
            self.uld or
            self.dld or
            self.swin or
            self.swup or
            self.swun
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='m2m:', name_='execReqArgsListType', namespacedef_='xmlns:m2m="http://www.onem2m.org/xml/protocols"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='execReqArgsListType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='m2m:', name_='execReqArgsListType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='m2m:', name_='execReqArgsListType'):
        pass
    def exportChildren(self, outfile, level, namespace_='m2m:', name_='execReqArgsListType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for rst_ in self.rst:
            rst_.export(outfile, level, namespace_, name_='rst', pretty_print=pretty_print)
        for rbo_ in self.rbo:
            rbo_.export(outfile, level, namespace_, name_='rbo', pretty_print=pretty_print)
        for uld_ in self.uld:
            uld_.export(outfile, level, namespace_, name_='uld', pretty_print=pretty_print)
        for dld_ in self.dld:
            dld_.export(outfile, level, namespace_, name_='dld', pretty_print=pretty_print)
        for swin_ in self.swin:
            swin_.export(outfile, level, namespace_, name_='swin', pretty_print=pretty_print)
        for swup_ in self.swup:
            swup_.export(outfile, level, namespace_, name_='swup', pretty_print=pretty_print)
        for swun_ in self.swun:
            swun_.export(outfile, level, namespace_, name_='swun', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'rst':
            obj_ = resetArgsType.factory()
            obj_.build(child_)
            self.rst.append(obj_)
            obj_.original_tagname_ = 'rst'
        elif nodeName_ == 'rbo':
            obj_ = rebootArgsType.factory()
            obj_.build(child_)
            self.rbo.append(obj_)
            obj_.original_tagname_ = 'rbo'
        elif nodeName_ == 'uld':
            obj_ = uploadArgsType.factory()
            obj_.build(child_)
            self.uld.append(obj_)
            obj_.original_tagname_ = 'uld'
        elif nodeName_ == 'dld':
            obj_ = downloadArgsType.factory()
            obj_.build(child_)
            self.dld.append(obj_)
            obj_.original_tagname_ = 'dld'
        elif nodeName_ == 'swin':
            obj_ = softwareInstallArgsType.factory()
            obj_.build(child_)
            self.swin.append(obj_)
            obj_.original_tagname_ = 'swin'
        elif nodeName_ == 'swup':
            obj_ = softwareUpdateArgsType.factory()
            obj_.build(child_)
            self.swup.append(obj_)
            obj_.original_tagname_ = 'swup'
        elif nodeName_ == 'swun':
            obj_ = softwareUninstallArgsType.factory()
            obj_.build(child_)
            self.swun.append(obj_)
            obj_.original_tagname_ = 'swun'
# end class execReqArgsListType


class mgmtLinkRef(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, typ=None, nm=None, valueOf_=None):
        self.original_tagname_ = None
        self.typ = _cast(None, typ)
        self.nm = _cast(None, nm)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if mgmtLinkRef.subclass:
            return mgmtLinkRef.subclass(*args_, **kwargs_)
        else:
            return mgmtLinkRef(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_typ(self): return self.typ
    def set_typ(self, typ): self.typ = typ
    def get_nm(self): return self.nm
    def set_nm(self, nm): self.nm = nm
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='m2m:', name_='mgmtLinkRef', namespacedef_='xmlns:m2m="http://www.onem2m.org/xml/protocols"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='mgmtLinkRef')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else str(self.valueOf_)).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='m2m:', name_='mgmtLinkRef', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='m2m:', name_='mgmtLinkRef'):
        if self.typ is not None and 'typ' not in already_processed:
            already_processed.add('typ')
            outfile.write(' typ=%s' % (quote_attrib(self.typ), ))
        if self.nm is not None and 'nm' not in already_processed:
            already_processed.add('nm')
            outfile.write(' nm=%s' % (quote_attrib(self.nm), ))
    def exportChildren(self, outfile, level, namespace_='m2m:', name_='mgmtLinkRef', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('typ', node)
        if value is not None and 'typ' not in already_processed:
            already_processed.add('typ')
            self.typ = value
        value = find_attr_value_('nm', node)
        if value is not None and 'nm' not in already_processed:
            already_processed.add('nm')
            self.nm = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class mgmtLinkRef


class childResourceRef(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, typ=None, nm=None, valueOf_=None):
        self.original_tagname_ = None
        self.typ = _cast(None, typ)
        self.nm = _cast(None, nm)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if childResourceRef.subclass:
            return childResourceRef.subclass(*args_, **kwargs_)
        else:
            return childResourceRef(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_typ(self): return self.typ
    def set_typ(self, typ): self.typ = typ
    def get_nm(self): return self.nm
    def set_nm(self, nm): self.nm = nm
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='m2m:', name_='childResourceRef', namespacedef_='xmlns:m2m="http://www.onem2m.org/xml/protocols"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='childResourceRef')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else str(self.valueOf_)).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='m2m:', name_='childResourceRef', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='m2m:', name_='childResourceRef'):
        if self.typ is not None and 'typ' not in already_processed:
            already_processed.add('typ')
            outfile.write(' typ=%s' % (quote_attrib(self.typ), ))
        if self.nm is not None and 'nm' not in already_processed:
            already_processed.add('nm')
            outfile.write(' nm=%s' % (quote_attrib(self.nm), ))
    def exportChildren(self, outfile, level, namespace_='m2m:', name_='childResourceRef', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('typ', node)
        if value is not None and 'typ' not in already_processed:
            already_processed.add('typ')
            self.typ = value
        value = find_attr_value_('nm', node)
        if value is not None and 'nm' not in already_processed:
            already_processed.add('nm')
            self.nm = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class childResourceRef


class responseTypeInfo(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, rtv=None, nu=None):
        self.original_tagname_ = None
        self.rtv = rtv
        self.nu = nu
    def factory(*args_, **kwargs_):
        if responseTypeInfo.subclass:
            return responseTypeInfo.subclass(*args_, **kwargs_)
        else:
            return responseTypeInfo(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_rtv(self): return self.rtv
    def set_rtv(self, rtv): self.rtv = rtv
    def get_nu(self): return self.nu
    def set_nu(self, nu): self.nu = nu
    def hasContent_(self):
        if (
            self.rtv is not None or
            self.nu is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='m2m:', name_='responseTypeInfo', namespacedef_='xmlns:m2m="http://www.onem2m.org/xml/protocols"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='responseTypeInfo')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='m2m:', name_='responseTypeInfo', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='m2m:', name_='responseTypeInfo'):
        pass
    def exportChildren(self, outfile, level, namespace_='m2m:', name_='responseTypeInfo', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.rtv is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srtv>%s</%srtv>%s' % (namespace_, self.gds_format_string(quote_xml(self.rtv).encode(ExternalEncoding), input_name='rtv'), namespace_, eol_))
        if self.nu is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snu>%s</%snu>%s' % (namespace_, self.gds_format_string(quote_xml(self.nu).encode(ExternalEncoding), input_name='nu'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'rtv':
            rtv_ = child_.text
            rtv_ = self.gds_validate_string(rtv_, node, 'rtv')
            self.rtv = rtv_
        elif nodeName_ == 'nu':
            nu_ = child_.text
            nu_ = self.gds_validate_string(nu_, node, 'nu')
            self.nu = nu_
# end class responseTypeInfo


class operationResult(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, rsc=None, rqi=None, pc=None, to=None, fr=None, ot=None, rset=None, ec=None):
        self.original_tagname_ = None
        self.rsc = rsc
        self.rqi = rqi
        self.validate_requestID(self.rqi)
        self.pc = pc
        self.to = to
        self.fr = fr
        self.validate_ID(self.fr)
        self.ot = ot
        self.validate_timestamp(self.ot)
        self.rset = rset
        self.validate_absRelTimestamp(self.rset)
        self.ec = ec
        self.validate_eventCat(self.ec)
    def factory(*args_, **kwargs_):
        if operationResult.subclass:
            return operationResult.subclass(*args_, **kwargs_)
        else:
            return operationResult(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_rsc(self): return self.rsc
    def set_rsc(self, rsc): self.rsc = rsc
    def get_rqi(self): return self.rqi
    def set_rqi(self, rqi): self.rqi = rqi
    def get_pc(self): return self.pc
    def set_pc(self, pc): self.pc = pc
    def get_to(self): return self.to
    def set_to(self, to): self.to = to
    def get_fr(self): return self.fr
    def set_fr(self, fr): self.fr = fr
    def get_ot(self): return self.ot
    def set_ot(self, ot): self.ot = ot
    def get_rset(self): return self.rset
    def set_rset(self, rset): self.rset = rset
    def get_ec(self): return self.ec
    def set_ec(self, ec): self.ec = ec
    def validate_requestID(self, value):
        # Validate type requestID, a restriction on xs:token.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_ID(self, value):
        # Validate type ID, a restriction on xs:anyURI.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_timestamp(self, value):
        # Validate type timestamp, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_timestamp_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_timestamp_patterns_, ))
    validate_timestamp_patterns_ = [['^\\d{4}(0[1-9]|1[0-2])(0[1-9]|[1-2]\\d|30|31)T([01]\\d|2[0-3])[0-5]\\d[0-5]\\d(,\\d{1,6})?$']]
    def validate_absRelTimestamp(self, value):
        # Validate type absRelTimestamp, a restriction on xs:long.
        pass
    def validate_eventCat(self, value):
        # Validate type eventCat, a restriction on None.
        pass
    def hasContent_(self):
        if (
            self.rsc is not None or
            self.rqi is not None or
            self.pc is not None or
            self.to is not None or
            self.fr is not None or
            self.ot is not None or
            self.rset is not None or
            self.ec is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='m2m:', name_='operationResult', namespacedef_='xmlns:m2m="http://www.onem2m.org/xml/protocols"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='operationResult')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='m2m:', name_='operationResult', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='m2m:', name_='operationResult'):
        pass
    def exportChildren(self, outfile, level, namespace_='m2m:', name_='operationResult', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.rsc is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srsc>%s</%srsc>%s' % (namespace_, self.gds_format_string(quote_xml(self.rsc).encode(ExternalEncoding), input_name='rsc'), namespace_, eol_))
        if self.rqi is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srqi>%s</%srqi>%s' % (namespace_, self.gds_format_string(quote_xml(self.rqi).encode(ExternalEncoding), input_name='rqi'), namespace_, eol_))
        if self.pc is not None:
            self.pc.export(outfile, level, namespace_, name_='pc', pretty_print=pretty_print)
        if self.to is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sto>%s</%sto>%s' % (namespace_, self.gds_format_string(quote_xml(self.to).encode(ExternalEncoding), input_name='to'), namespace_, eol_))
        if self.fr is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfr>%s</%sfr>%s' % (namespace_, self.gds_format_string(quote_xml(self.fr).encode(ExternalEncoding), input_name='fr'), namespace_, eol_))
        if self.ot is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sot>%s</%sot>%s' % (namespace_, self.gds_format_string(quote_xml(self.ot).encode(ExternalEncoding), input_name='ot'), namespace_, eol_))
        if self.rset is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srset>%s</%srset>%s' % (namespace_, self.gds_format_integer(self.rset, input_name='rset'), namespace_, eol_))
        if self.ec is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sec>%s</%sec>%s' % (namespace_, self.gds_format_string(quote_xml(self.ec).encode(ExternalEncoding), input_name='ec'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'rsc':
            rsc_ = child_.text
            rsc_ = self.gds_validate_string(rsc_, node, 'rsc')
            self.rsc = rsc_
        elif nodeName_ == 'rqi':
            rqi_ = child_.text
            rqi_ = re_.sub(String_cleanup_pat_, " ", rqi_).strip()
            rqi_ = self.gds_validate_string(rqi_, node, 'rqi')
            self.rqi = rqi_
            # validate type requestID
            self.validate_requestID(self.rqi)
        elif nodeName_ == 'pc':
            obj_ = primitiveContent.factory()
            obj_.build(child_)
            self.pc = obj_
            obj_.original_tagname_ = 'pc'
        elif nodeName_ == 'to':
            to_ = child_.text
            to_ = self.gds_validate_string(to_, node, 'to')
            self.to = to_
        elif nodeName_ == 'fr':
            fr_ = child_.text
            fr_ = self.gds_validate_string(fr_, node, 'fr')
            self.fr = fr_
            # validate type ID
            self.validate_ID(self.fr)
        elif nodeName_ == 'ot':
            ot_ = child_.text
            ot_ = self.gds_validate_string(ot_, node, 'ot')
            self.ot = ot_
            # validate type timestamp
            self.validate_timestamp(self.ot)
        elif nodeName_ == 'rset':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'rset')
            self.rset = ival_
            # validate type absRelTimestamp
            self.validate_absRelTimestamp(self.rset)
        elif nodeName_ == 'ec':
            ec_ = child_.text
            ec_ = self.gds_validate_string(ec_, node, 'ec')
            self.ec = ec_
            # validate type eventCat
            self.validate_eventCat(self.ec)
# end class operationResult


class resource(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, rn=None, ty=None, ri=None, pi=None, ct=None, lt=None, lbl=None, extensiontype_=None):
        self.original_tagname_ = None
        self.rn = _cast(None, rn)
        self.ty = ty
        self.ri = ri
        self.validate_ID(self.ri)
        self.pi = pi
        self.validate_nhURI(self.pi)
        self.ct = ct
        self.validate_timestamp(self.ct)
        self.lt = lt
        self.validate_timestamp(self.lt)
        self.lbl = lbl
        self.validate_labels(self.lbl)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if resource.subclass:
            return resource.subclass(*args_, **kwargs_)
        else:
            return resource(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ty(self): return self.ty
    def set_ty(self, ty): self.ty = ty
    def get_ri(self): return self.ri
    def set_ri(self, ri): self.ri = ri
    def get_pi(self): return self.pi
    def set_pi(self, pi): self.pi = pi
    def get_ct(self): return self.ct
    def set_ct(self, ct): self.ct = ct
    def get_lt(self): return self.lt
    def set_lt(self, lt): self.lt = lt
    def get_lbl(self): return self.lbl
    def set_lbl(self, lbl): self.lbl = lbl
    def get_rn(self): return self.rn
    def set_rn(self, rn): self.rn = rn
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_ID(self, value):
        # Validate type ID, a restriction on xs:anyURI.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_nhURI(self, value):
        # Validate type nhURI, a restriction on xs:anyURI.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_timestamp(self, value):
        # Validate type timestamp, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_timestamp_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_timestamp_patterns_, ))
    validate_timestamp_patterns_ = [['^\\d{4}(0[1-9]|1[0-2])(0[1-9]|[1-2]\\d|30|31)T([01]\\d|2[0-3])[0-5]\\d[0-5]\\d(,\\d{1,6})?$']]
    def validate_labels(self, value):
        # Validate type labels, a restriction on xs:token.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on labels' % {"value" : value} )
    def hasContent_(self):
        if (
            self.ty is not None or
            self.ri is not None or
            self.pi is not None or
            self.ct is not None or
            self.lt is not None or
            self.lbl is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='m2m:', name_='resource', namespacedef_='xmlns:m2m="http://www.onem2m.org/xml/protocols"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='resource')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='m2m:', name_='resource', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='m2m:', name_='resource'):
        if self.rn is not None and 'rn' not in already_processed:
            already_processed.add('rn')
            outfile.write(' rn=%s' % (quote_attrib(self.rn), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='m2m:', name_='resource', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ty is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sty>%s</%sty>%s' % (namespace_, self.gds_format_string(quote_xml(self.ty).encode(ExternalEncoding), input_name='ty'), namespace_, eol_))
        if self.ri is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sri>%s</%sri>%s' % (namespace_, self.gds_format_string(quote_xml(self.ri).encode(ExternalEncoding), input_name='ri'), namespace_, eol_))
        if self.pi is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spi>%s</%spi>%s' % (namespace_, self.gds_format_string(quote_xml(self.pi).encode(ExternalEncoding), input_name='pi'), namespace_, eol_))
        if self.ct is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sct>%s</%sct>%s' % (namespace_, self.gds_format_string(quote_xml(self.ct).encode(ExternalEncoding), input_name='ct'), namespace_, eol_))
        if self.lt is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slt>%s</%slt>%s' % (namespace_, self.gds_format_string(quote_xml(self.lt).encode(ExternalEncoding), input_name='lt'), namespace_, eol_))
        if self.lbl is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slbl>%s</%slbl>%s' % (namespace_, self.gds_format_string(quote_xml(' '.join(self.lbl)).encode(ExternalEncoding), input_name='lbl'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('rn', node)
        if value is not None and 'rn' not in already_processed:
            already_processed.add('rn')
            self.rn = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ty':
            ty_ = child_.text
            ty_ = self.gds_validate_string(ty_, node, 'ty')
            self.ty = ty_
        elif nodeName_ == 'ri':
            ri_ = child_.text
            ri_ = self.gds_validate_string(ri_, node, 'ri')
            self.ri = ri_
            # validate type ID
            self.validate_ID(self.ri)
        elif nodeName_ == 'pi':
            pi_ = child_.text
            pi_ = self.gds_validate_string(pi_, node, 'pi')
            self.pi = pi_
            # validate type nhURI
            self.validate_nhURI(self.pi)
        elif nodeName_ == 'ct':
            ct_ = child_.text
            ct_ = self.gds_validate_string(ct_, node, 'ct')
            self.ct = ct_
            # validate type timestamp
            self.validate_timestamp(self.ct)
        elif nodeName_ == 'lt':
            lt_ = child_.text
            lt_ = self.gds_validate_string(lt_, node, 'lt')
            self.lt = lt_
            # validate type timestamp
            self.validate_timestamp(self.lt)
        elif nodeName_ == 'lbl':
            lbl_ = child_.text
            lbl_ = re_.sub(String_cleanup_pat_, " ", lbl_).strip()
            self.lbl = lbl_
            # validate type labels
            self.validate_labels(self.lbl)

    def to_JSON(self):
        mgmtObjList = ["fwr", "swr", "mem", "ani", "andi", "bat", "dvi", "dvc", "rbo", "evl", "cmp"]
        resourceName = self.__class__.__name__
        if resourceName in mgmtObjList:
            resourceName = "mgo"
        self.payload = {"m2m:%s"% resourceName:{k: v for k, v in self.__dict__.iteritems() if v is not None}}
        return json.dumps(self, default=lambda o: o.payload,
            sort_keys=True, indent=4)
# end class resource


class regularResource(resource):
    subclass = None
    superclass = resource
    def __init__(self, rn=None, ty=None, ri=None, pi=None, ct=None, lt=None, lbl=None, acpi=None, et=None, extensiontype_=None):
        self.original_tagname_ = None
        super(regularResource, self).__init__(rn, ty, ri, pi, ct, lt, lbl, extensiontype_, )
        self.acpi = acpi
        self.validate_acpType(self.acpi)
        self.et = et
        self.validate_timestamp(self.et)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if regularResource.subclass:
            return regularResource.subclass(*args_, **kwargs_)
        else:
            return regularResource(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_acpi(self): return self.acpi
    def set_acpi(self, acpi): self.acpi = acpi
    def get_et(self): return self.et
    def set_et(self, et): self.et = et
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_acpType(self, value):
        # Validate type acpType, a restriction on m2m:ID.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on acpType' % {"value" : value} )
    def validate_timestamp(self, value):
        # Validate type timestamp, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_timestamp_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_timestamp_patterns_, ))
    validate_timestamp_patterns_ = [['^\\d{4}(0[1-9]|1[0-2])(0[1-9]|[1-2]\\d|30|31)T([01]\\d|2[0-3])[0-5]\\d[0-5]\\d(,\\d{1,6})?$']]
    def hasContent_(self):
        if (
            self.acpi is not None or
            self.et is not None or
            super(regularResource, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='m2m:', name_='regularResource', namespacedef_='xmlns:m2m="http://www.onem2m.org/xml/protocols"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='regularResource')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='m2m:', name_='regularResource', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='m2m:', name_='regularResource'):
        super(regularResource, self).exportAttributes(outfile, level, already_processed, namespace_, name_='regularResource')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='m2m:', name_='regularResource', fromsubclass_=False, pretty_print=True):
        super(regularResource, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.acpi is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sacpi>%s</%sacpi>%s' % (namespace_, self.gds_format_string(quote_xml(' '.join(self.acpi)).encode(ExternalEncoding), input_name='acpi'), namespace_, eol_))
        if self.et is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%set>%s</%set>%s' % (namespace_, self.gds_format_string(quote_xml(self.et).encode(ExternalEncoding), input_name='et'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(regularResource, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'acpi':
            acpi_ = child_.text
            self.acpi = acpi_
            # validate type acpType
            self.validate_acpType(self.acpi)
        elif nodeName_ == 'et':
            et_ = child_.text
            et_ = self.gds_validate_string(et_, node, 'et')
            self.et = et_
            # validate type timestamp
            self.validate_timestamp(self.et)
        super(regularResource, self).buildChildren(child_, node, nodeName_, True)
# end class regularResource


class announceableResource(regularResource):
    subclass = None
    superclass = regularResource
    def __init__(self, rn=None, ty=None, ri=None, pi=None, ct=None, lt=None, lbl=None, acpi=None, et=None, at=None, aa=None, extensiontype_=None):
        self.original_tagname_ = None
        super(announceableResource, self).__init__(rn, ty, ri, pi, ct, lt, lbl, acpi, et, extensiontype_, )
        self.at = at
        self.validate_listOfURIs(self.at)
        self.aa = aa
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if announceableResource.subclass:
            return announceableResource.subclass(*args_, **kwargs_)
        else:
            return announceableResource(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_at(self): return self.at
    def set_at(self, at): self.at = at
    def get_aa(self): return self.aa
    def set_aa(self, aa): self.aa = aa
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_listOfURIs(self, value):
        # Validate type listOfURIs, a restriction on xs:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on listOfURIs' % {"value" : value} )
    def hasContent_(self):
        if (
            self.at is not None or
            self.aa is not None or
            super(announceableResource, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='m2m:', name_='announceableResource', namespacedef_='xmlns:m2m="http://www.onem2m.org/xml/protocols"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='announceableResource')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='m2m:', name_='announceableResource', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='m2m:', name_='announceableResource'):
        super(announceableResource, self).exportAttributes(outfile, level, already_processed, namespace_, name_='announceableResource')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='m2m:', name_='announceableResource', fromsubclass_=False, pretty_print=True):
        super(announceableResource, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.at is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sat>%s</%sat>%s' % (namespace_, self.gds_format_string(quote_xml(' '.join(self.at)).encode(ExternalEncoding), input_name='at'), namespace_, eol_))
        if self.aa is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%saa>%s</%saa>%s' % (namespace_, self.gds_format_string(quote_xml(self.aa).encode(ExternalEncoding), input_name='aa'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(announceableResource, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'at':
            at_ = child_.text
            self.at = at_
            # validate type listOfURIs
            self.validate_listOfURIs(self.at)
        elif nodeName_ == 'aa':
            aa_ = child_.text
            aa_ = self.gds_validate_string(aa_, node, 'aa')
            self.aa = aa_
        super(announceableResource, self).buildChildren(child_, node, nodeName_, True)
# end class announceableResource


class announcedResource(resource):
    subclass = None
    superclass = resource
    def __init__(self, rn=None, ty=None, ri=None, pi=None, ct=None, lt=None, lbl=None, acpi=None, et=None, lnk=None, extensiontype_=None):
        self.original_tagname_ = None
        super(announcedResource, self).__init__(rn, ty, ri, pi, ct, lt, lbl, extensiontype_, )
        self.acpi = acpi
        self.validate_acpType(self.acpi)
        self.et = et
        self.validate_timestamp(self.et)
        self.lnk = lnk
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if announcedResource.subclass:
            return announcedResource.subclass(*args_, **kwargs_)
        else:
            return announcedResource(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_acpi(self): return self.acpi
    def set_acpi(self, acpi): self.acpi = acpi
    def get_et(self): return self.et
    def set_et(self, et): self.et = et
    def get_lnk(self): return self.lnk
    def set_lnk(self, lnk): self.lnk = lnk
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_acpType(self, value):
        # Validate type acpType, a restriction on m2m:ID.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on acpType' % {"value" : value} )
    def validate_timestamp(self, value):
        # Validate type timestamp, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_timestamp_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_timestamp_patterns_, ))
    validate_timestamp_patterns_ = [['^\\d{4}(0[1-9]|1[0-2])(0[1-9]|[1-2]\\d|30|31)T([01]\\d|2[0-3])[0-5]\\d[0-5]\\d(,\\d{1,6})?$']]
    def hasContent_(self):
        if (
            self.acpi is not None or
            self.et is not None or
            self.lnk is not None or
            super(announcedResource, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='m2m:', name_='announcedResource', namespacedef_='xmlns:m2m="http://www.onem2m.org/xml/protocols"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='announcedResource')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='m2m:', name_='announcedResource', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='m2m:', name_='announcedResource'):
        super(announcedResource, self).exportAttributes(outfile, level, already_processed, namespace_, name_='announcedResource')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='m2m:', name_='announcedResource', fromsubclass_=False, pretty_print=True):
        super(announcedResource, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.acpi is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sacpi>%s</%sacpi>%s' % (namespace_, self.gds_format_string(quote_xml(' '.join(self.acpi)).encode(ExternalEncoding), input_name='acpi'), namespace_, eol_))
        if self.et is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%set>%s</%set>%s' % (namespace_, self.gds_format_string(quote_xml(self.et).encode(ExternalEncoding), input_name='et'), namespace_, eol_))
        if self.lnk is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slnk>%s</%slnk>%s' % (namespace_, self.gds_format_string(quote_xml(self.lnk).encode(ExternalEncoding), input_name='lnk'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(announcedResource, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'acpi':
            acpi_ = child_.text
            self.acpi = acpi_
            # validate type acpType
            self.validate_acpType(self.acpi)
        elif nodeName_ == 'et':
            et_ = child_.text
            et_ = self.gds_validate_string(et_, node, 'et')
            self.et = et_
            # validate type timestamp
            self.validate_timestamp(self.et)
        elif nodeName_ == 'lnk':
            lnk_ = child_.text
            lnk_ = self.gds_validate_string(lnk_, node, 'lnk')
            self.lnk = lnk_
        super(announcedResource, self).buildChildren(child_, node, nodeName_, True)
# end class announcedResource


class announceableSubordinateResource(resource):
    subclass = None
    superclass = resource
    def __init__(self, rn=None, ty=None, ri=None, pi=None, ct=None, lt=None, lbl=None, et=None, at=None, aa=None):
        self.original_tagname_ = None
        super(announceableSubordinateResource, self).__init__(rn, ty, ri, pi, ct, lt, lbl, )
        self.et = et
        self.validate_timestamp(self.et)
        self.at = at
        self.validate_listOfURIs(self.at)
        self.aa = aa
    def factory(*args_, **kwargs_):
        if announceableSubordinateResource.subclass:
            return announceableSubordinateResource.subclass(*args_, **kwargs_)
        else:
            return announceableSubordinateResource(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_et(self): return self.et
    def set_et(self, et): self.et = et
    def get_at(self): return self.at
    def set_at(self, at): self.at = at
    def get_aa(self): return self.aa
    def set_aa(self, aa): self.aa = aa
    def validate_timestamp(self, value):
        # Validate type timestamp, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_timestamp_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_timestamp_patterns_, ))
    validate_timestamp_patterns_ = [['^\\d{4}(0[1-9]|1[0-2])(0[1-9]|[1-2]\\d|30|31)T([01]\\d|2[0-3])[0-5]\\d[0-5]\\d(,\\d{1,6})?$']]
    def validate_listOfURIs(self, value):
        # Validate type listOfURIs, a restriction on xs:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on listOfURIs' % {"value" : value} )
    def hasContent_(self):
        if (
            self.et is not None or
            self.at is not None or
            self.aa is not None or
            super(announceableSubordinateResource, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='m2m:', name_='announceableSubordinateResource', namespacedef_='xmlns:m2m="http://www.onem2m.org/xml/protocols"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='announceableSubordinateResource')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='m2m:', name_='announceableSubordinateResource', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='m2m:', name_='announceableSubordinateResource'):
        super(announceableSubordinateResource, self).exportAttributes(outfile, level, already_processed, namespace_, name_='announceableSubordinateResource')
    def exportChildren(self, outfile, level, namespace_='m2m:', name_='announceableSubordinateResource', fromsubclass_=False, pretty_print=True):
        super(announceableSubordinateResource, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.et is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%set>%s</%set>%s' % (namespace_, self.gds_format_string(quote_xml(self.et).encode(ExternalEncoding), input_name='et'), namespace_, eol_))
        if self.at is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sat>%s</%sat>%s' % (namespace_, self.gds_format_string(quote_xml(' '.join(self.at)).encode(ExternalEncoding), input_name='at'), namespace_, eol_))
        if self.aa is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%saa>%s</%saa>%s' % (namespace_, self.gds_format_string(quote_xml(self.aa).encode(ExternalEncoding), input_name='aa'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(announceableSubordinateResource, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'et':
            et_ = child_.text
            et_ = self.gds_validate_string(et_, node, 'et')
            self.et = et_
            # validate type timestamp
            self.validate_timestamp(self.et)
        elif nodeName_ == 'at':
            at_ = child_.text
            self.at = at_
            # validate type listOfURIs
            self.validate_listOfURIs(self.at)
        elif nodeName_ == 'aa':
            aa_ = child_.text
            aa_ = self.gds_validate_string(aa_, node, 'aa')
            self.aa = aa_
        super(announceableSubordinateResource, self).buildChildren(child_, node, nodeName_, True)
# end class announceableSubordinateResource


class announcedSubordinateResource(resource):
    subclass = None
    superclass = resource
    def __init__(self, rn=None, ty=None, ri=None, pi=None, ct=None, lt=None, lbl=None, et=None, lnk=None):
        self.original_tagname_ = None
        super(announcedSubordinateResource, self).__init__(rn, ty, ri, pi, ct, lt, lbl, )
        self.et = et
        self.validate_timestamp(self.et)
        self.lnk = lnk
    def factory(*args_, **kwargs_):
        if announcedSubordinateResource.subclass:
            return announcedSubordinateResource.subclass(*args_, **kwargs_)
        else:
            return announcedSubordinateResource(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_et(self): return self.et
    def set_et(self, et): self.et = et
    def get_lnk(self): return self.lnk
    def set_lnk(self, lnk): self.lnk = lnk
    def validate_timestamp(self, value):
        # Validate type timestamp, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_timestamp_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_timestamp_patterns_, ))
    validate_timestamp_patterns_ = [['^\\d{4}(0[1-9]|1[0-2])(0[1-9]|[1-2]\\d|30|31)T([01]\\d|2[0-3])[0-5]\\d[0-5]\\d(,\\d{1,6})?$']]
    def hasContent_(self):
        if (
            self.et is not None or
            self.lnk is not None or
            super(announcedSubordinateResource, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='m2m:', name_='announcedSubordinateResource', namespacedef_='xmlns:m2m="http://www.onem2m.org/xml/protocols"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='announcedSubordinateResource')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='m2m:', name_='announcedSubordinateResource', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='m2m:', name_='announcedSubordinateResource'):
        super(announcedSubordinateResource, self).exportAttributes(outfile, level, already_processed, namespace_, name_='announcedSubordinateResource')
    def exportChildren(self, outfile, level, namespace_='m2m:', name_='announcedSubordinateResource', fromsubclass_=False, pretty_print=True):
        super(announcedSubordinateResource, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.et is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%set>%s</%set>%s' % (namespace_, self.gds_format_string(quote_xml(self.et).encode(ExternalEncoding), input_name='et'), namespace_, eol_))
        if self.lnk is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slnk>%s</%slnk>%s' % (namespace_, self.gds_format_string(quote_xml(self.lnk).encode(ExternalEncoding), input_name='lnk'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(announcedSubordinateResource, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'et':
            et_ = child_.text
            et_ = self.gds_validate_string(et_, node, 'et')
            self.et = et_
            # validate type timestamp
            self.validate_timestamp(self.et)
        elif nodeName_ == 'lnk':
            lnk_ = child_.text
            lnk_ = self.gds_validate_string(lnk_, node, 'lnk')
            self.lnk = lnk_
        super(announcedSubordinateResource, self).buildChildren(child_, node, nodeName_, True)
# end class announcedSubordinateResource


class mgmtResource(announceableResource):
    subclass = None
    superclass = announceableResource
    def __init__(self, rn=None, ty=None, ri=None, pi=None, ct=None, lt=None, lbl=None, acpi=None, et=None, at=None, aa=None, mgd=None, obis=None, obps=None, dc=None):
        self.original_tagname_ = None
        super(mgmtResource, self).__init__(rn, ty, ri, pi, ct, lt, lbl, acpi, et, at, aa, )
        self.mgd = mgd
        self.obis = obis
        self.validate_listOfURIs(self.obis)
        self.obps = obps
        self.validate_listOfURIs(self.obps)
        self.dc = dc
    def factory(*args_, **kwargs_):
        if mgmtResource.subclass:
            return mgmtResource.subclass(*args_, **kwargs_)
        else:
            return mgmtResource(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_mgd(self): return self.mgd
    def set_mgd(self, mgd): self.mgd = mgd
    def get_obis(self): return self.obis
    def set_obis(self, obis): self.obis = obis
    def get_obps(self): return self.obps
    def set_obps(self, obps): self.obps = obps
    def get_dc(self): return self.dc
    def set_dc(self, dc): self.dc = dc
    def validate_listOfURIs(self, value):
        # Validate type listOfURIs, a restriction on xs:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on listOfURIs' % {"value" : value} )
    def hasContent_(self):
        if (
            self.mgd is not None or
            self.obis is not None or
            self.obps is not None or
            self.dc is not None or
            super(mgmtResource, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='m2m:', name_='mgmtResource', namespacedef_='xmlns:m2m="http://www.onem2m.org/xml/protocols"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='mgmtResource')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='m2m:', name_='mgmtResource', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='m2m:', name_='mgmtResource'):
        super(mgmtResource, self).exportAttributes(outfile, level, already_processed, namespace_, name_='mgmtResource')
    def exportChildren(self, outfile, level, namespace_='m2m:', name_='mgmtResource', fromsubclass_=False, pretty_print=True):
        super(mgmtResource, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.mgd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smgd>%s</%smgd>%s' % (namespace_, self.gds_format_string(quote_xml(self.mgd).encode(ExternalEncoding), input_name='mgd'), namespace_, eol_))
        if self.obis is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sobis>%s</%sobis>%s' % (namespace_, self.gds_format_string(quote_xml(' '.join(self.obis)).encode(ExternalEncoding), input_name='obis'), namespace_, eol_))
        if self.obps is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sobps>%s</%sobps>%s' % (namespace_, self.gds_format_string(quote_xml(' '.join(self.obps)).encode(ExternalEncoding), input_name='obps'), namespace_, eol_))
        if self.dc is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdc>%s</%sdc>%s' % (namespace_, self.gds_format_string(quote_xml(self.dc).encode(ExternalEncoding), input_name='dc'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(mgmtResource, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'mgd':
            mgd_ = child_.text
            mgd_ = self.gds_validate_string(mgd_, node, 'mgd')
            self.mgd = mgd_
        elif nodeName_ == 'obis':
            obis_ = child_.text
            self.obis = obis_
            # validate type listOfURIs
            self.validate_listOfURIs(self.obis)
        elif nodeName_ == 'obps':
            obps_ = child_.text
            self.obps = obps_
            # validate type listOfURIs
            self.validate_listOfURIs(self.obps)
        elif nodeName_ == 'dc':
            dc_ = child_.text
            dc_ = self.gds_validate_string(dc_, node, 'dc')
            self.dc = dc_
        super(mgmtResource, self).buildChildren(child_, node, nodeName_, True)
# end class mgmtResource


class announcedMgmtResource(announcedResource):
    subclass = None
    superclass = announcedResource
    def __init__(self, rn=None, ty=None, ri=None, pi=None, ct=None, lt=None, lbl=None, acpi=None, et=None, lnk=None, mgd=None, obis=None, obps=None, dc=None):
        self.original_tagname_ = None
        super(announcedMgmtResource, self).__init__(rn, ty, ri, pi, ct, lt, lbl, acpi, et, lnk, )
        self.mgd = mgd
        self.obis = obis
        self.validate_listOfURIs(self.obis)
        self.obps = obps
        self.validate_listOfURIs(self.obps)
        self.dc = dc
    def factory(*args_, **kwargs_):
        if announcedMgmtResource.subclass:
            return announcedMgmtResource.subclass(*args_, **kwargs_)
        else:
            return announcedMgmtResource(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_mgd(self): return self.mgd
    def set_mgd(self, mgd): self.mgd = mgd
    def get_obis(self): return self.obis
    def set_obis(self, obis): self.obis = obis
    def get_obps(self): return self.obps
    def set_obps(self, obps): self.obps = obps
    def get_dc(self): return self.dc
    def set_dc(self, dc): self.dc = dc
    def validate_listOfURIs(self, value):
        # Validate type listOfURIs, a restriction on xs:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on listOfURIs' % {"value" : value} )
    def hasContent_(self):
        if (
            self.mgd is not None or
            self.obis is not None or
            self.obps is not None or
            self.dc is not None or
            super(announcedMgmtResource, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='m2m:', name_='announcedMgmtResource', namespacedef_='xmlns:m2m="http://www.onem2m.org/xml/protocols"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='announcedMgmtResource')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='m2m:', name_='announcedMgmtResource', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='m2m:', name_='announcedMgmtResource'):
        super(announcedMgmtResource, self).exportAttributes(outfile, level, already_processed, namespace_, name_='announcedMgmtResource')
    def exportChildren(self, outfile, level, namespace_='m2m:', name_='announcedMgmtResource', fromsubclass_=False, pretty_print=True):
        super(announcedMgmtResource, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.mgd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smgd>%s</%smgd>%s' % (namespace_, self.gds_format_string(quote_xml(self.mgd).encode(ExternalEncoding), input_name='mgd'), namespace_, eol_))
        if self.obis is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sobis>%s</%sobis>%s' % (namespace_, self.gds_format_string(quote_xml(' '.join(self.obis)).encode(ExternalEncoding), input_name='obis'), namespace_, eol_))
        if self.obps is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sobps>%s</%sobps>%s' % (namespace_, self.gds_format_string(quote_xml(' '.join(self.obps)).encode(ExternalEncoding), input_name='obps'), namespace_, eol_))
        if self.dc is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdc>%s</%sdc>%s' % (namespace_, self.gds_format_string(quote_xml(self.dc).encode(ExternalEncoding), input_name='dc'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(announcedMgmtResource, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'mgd':
            mgd_ = child_.text
            mgd_ = self.gds_validate_string(mgd_, node, 'mgd')
            self.mgd = mgd_
        elif nodeName_ == 'obis':
            obis_ = child_.text
            self.obis = obis_
            # validate type listOfURIs
            self.validate_listOfURIs(self.obis)
        elif nodeName_ == 'obps':
            obps_ = child_.text
            self.obps = obps_
            # validate type listOfURIs
            self.validate_listOfURIs(self.obps)
        elif nodeName_ == 'dc':
            dc_ = child_.text
            dc_ = self.gds_validate_string(dc_, node, 'dc')
            self.dc = dc_
        super(announcedMgmtResource, self).buildChildren(child_, node, nodeName_, True)
# end class announcedMgmtResource


GDSClassesMapping = {
    'rt': responseTypeInfo,
    'swin': softwareInstallArgsType,
    'dld': downloadArgsType,
    'swup': softwareUpdateArgsType,
    'rbo': rebootArgsType,
    'pc': primitiveContent,
    'fc': filterCriteria,
    'atr': attribute,
    'swun': softwareUninstallArgsType,
    'rst': resetArgsType,
    'any': anyArgType,
    'uld': uploadArgsType,
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'deliveryMetaData'
        rootClass = deliveryMetaData
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='xmlns:m2m="http://www.onem2m.org/xml/protocols"',
            pretty_print=True)
    return rootObj


def parseEtree(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'deliveryMetaData'
        rootClass = deliveryMetaData
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(content)
        sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False):
    from StringIO import StringIO
    parser = None
    doc = parsexml_(StringIO(inString), parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'deliveryMetaData'
        rootClass = deliveryMetaData
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='xmlns:m2m="http://www.onem2m.org/xml/protocols"')
    return rootObj


def parseLiteral(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'deliveryMetaData'
        rootClass = deliveryMetaData
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('#from common import *\n\n')
        sys.stdout.write('import common as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "actionStatus",
    "aggregatedRequest",
    "announceableResource",
    "announceableSubordinateResource",
    "announcedMgmtResource",
    "announcedResource",
    "announcedSubordinateResource",
    "anyArgType",
    "attribute",
    "childResourceRef",
    "deliveryMetaData",
    "downloadArgsType",
    "execReqArgsListType",
    "filterCriteria",
    "metaInformation",
    "mgmtLinkRef",
    "mgmtResource",
    "operationResult",
    "primitiveContent",
    "rebootArgsType",
    "regularResource",
    "resetArgsType",
    "resource",
    "responseTypeInfo",
    "scheduleEntries",
    "softwareInstallArgsType",
    "softwareUninstallArgsType",
    "softwareUpdateArgsType",
    "uploadArgsType"
]
