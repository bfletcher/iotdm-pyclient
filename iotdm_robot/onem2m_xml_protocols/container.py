#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Mon Feb  1 17:27:38 2016 by generateDS.py version 2.18a.
#
# Command line options:
#   ('-o', 'container.py')
#
# Command line arguments:
#   shortName-XSD-v2_3_0/CDT-container-v2_3_0.xsd
#
# Command line:
#   generateDS.py -o "container.py" shortName-XSD-v2_3_0/CDT-container-v2_3_0.xsd
#
# Current working directory (os.getcwd()):
#   generateDS-2.18a0
#

import sys
import json
import re as re_
import base64
import datetime as datetime_
import warnings as warnings_
from lxml import etree as etree_


Validate_simpletypes_ = True


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        parser = etree_.ETCompatXMLParser()
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError as exp:

    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return values
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_validate_float(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(
                        node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (time_parts[0], micro_seconds, )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.  We should:
            # - AND the outer elements
            # - OR the inner elements
            found1 = True
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    if re_.search(patterns2, target) is not None:
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.iteritems()))


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'ascii'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace, pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, namespace, name, pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name, base64.b64encode(self.value), self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0):
        self.name = name
        self.data_type = data_type
        self.container = container
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class deliveryMetaData(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, tcop=None, tcin=None):
        self.original_tagname_ = None
        self.tcop = tcop
        self.tcin = tcin
        self.validate_listOfM2MID(self.tcin)
    def factory(*args_, **kwargs_):
        if deliveryMetaData.subclass:
            return deliveryMetaData.subclass(*args_, **kwargs_)
        else:
            return deliveryMetaData(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_tcop(self): return self.tcop
    def set_tcop(self, tcop): self.tcop = tcop
    def get_tcin(self): return self.tcin
    def set_tcin(self, tcin): self.tcin = tcin
    def validate_listOfM2MID(self, value):
        # Validate type listOfM2MID, a restriction on m2m:ID.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on listOfM2MID' % {"value" : value} )
    def hasContent_(self):
        if (
            self.tcop is not None or
            self.tcin is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='m2m:', name_='deliveryMetaData', namespacedef_='xmlns:m2m="http://www.onem2m.org/xml/protocols"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='deliveryMetaData')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='m2m:', name_='deliveryMetaData', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='m2m:', name_='deliveryMetaData'):
        pass
    def exportChildren(self, outfile, level, namespace_='m2m:', name_='deliveryMetaData', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.tcop is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stcop>%s</%stcop>%s' % (namespace_, self.gds_format_boolean(self.tcop, input_name='tcop'), namespace_, eol_))
        if self.tcin is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stcin>%s</%stcin>%s' % (namespace_, self.gds_format_string(quote_xml(' '.join(self.tcin)).encode(ExternalEncoding), input_name='tcin'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'tcop':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'tcop')
            self.tcop = ival_
        elif nodeName_ == 'tcin':
            tcin_ = child_.text
            self.tcin = tcin_
            # validate type listOfM2MID
            self.validate_listOfM2MID(self.tcin)
# end class deliveryMetaData


class aggregatedRequest(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, req=None):
        self.original_tagname_ = None
        if req is None:
            self.req = []
        else:
            self.req = req
    def factory(*args_, **kwargs_):
        if aggregatedRequest.subclass:
            return aggregatedRequest.subclass(*args_, **kwargs_)
        else:
            return aggregatedRequest(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_req(self): return self.req
    def set_req(self, req): self.req = req
    def add_req(self, value): self.req.append(value)
    def insert_req_at(self, index, value): self.req.insert(index, value)
    def replace_req_at(self, index, value): self.req[index] = value
    def hasContent_(self):
        if (
            self.req
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='m2m:', name_='aggregatedRequest', namespacedef_='xmlns:m2m="http://www.onem2m.org/xml/protocols"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='aggregatedRequest')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='m2m:', name_='aggregatedRequest', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='m2m:', name_='aggregatedRequest'):
        pass
    def exportChildren(self, outfile, level, namespace_='m2m:', name_='aggregatedRequest', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for req_ in self.req:
            req_.export(outfile, level, namespace_, name_='req', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'req':
            obj_ = reqType.factory()
            obj_.build(child_)
            self.req.append(obj_)
            obj_.original_tagname_ = 'req'
# end class aggregatedRequest


class metaInformation(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ty=None, nm=None, ot=None, rqet=None, rset=None, oet=None, rt=None, rp=None, rcn=None, ec=None, da=None, gid=None, fc=None, drt=None):
        self.original_tagname_ = None
        self.ty = ty
        self.validate_resourceType(self.ty)
        self.nm = nm
        self.ot = ot
        self.validate_timestamp(self.ot)
        self.rqet = rqet
        self.validate_absRelTimestamp(self.rqet)
        self.rset = rset
        self.validate_absRelTimestamp(self.rset)
        self.oet = oet
        self.validate_absRelTimestamp(self.oet)
        self.rt = rt
        self.rp = rp
        self.validate_absRelTimestamp(self.rp)
        self.rcn = rcn
        self.validate_resultContent(self.rcn)
        self.ec = ec
        self.validate_eventCat(self.ec)
        self.da = da
        self.gid = gid
        self.fc = fc
        self.drt = drt
        self.validate_discResType(self.drt)
    def factory(*args_, **kwargs_):
        if metaInformation.subclass:
            return metaInformation.subclass(*args_, **kwargs_)
        else:
            return metaInformation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ty(self): return self.ty
    def set_ty(self, ty): self.ty = ty
    def get_nm(self): return self.nm
    def set_nm(self, nm): self.nm = nm
    def get_ot(self): return self.ot
    def set_ot(self, ot): self.ot = ot
    def get_rqet(self): return self.rqet
    def set_rqet(self, rqet): self.rqet = rqet
    def get_rset(self): return self.rset
    def set_rset(self, rset): self.rset = rset
    def get_oet(self): return self.oet
    def set_oet(self, oet): self.oet = oet
    def get_rt(self): return self.rt
    def set_rt(self, rt): self.rt = rt
    def get_rp(self): return self.rp
    def set_rp(self, rp): self.rp = rp
    def get_rcn(self): return self.rcn
    def set_rcn(self, rcn): self.rcn = rcn
    def get_ec(self): return self.ec
    def set_ec(self, ec): self.ec = ec
    def get_da(self): return self.da
    def set_da(self, da): self.da = da
    def get_gid(self): return self.gid
    def set_gid(self, gid): self.gid = gid
    def get_fc(self): return self.fc
    def set_fc(self, fc): self.fc = fc
    def get_drt(self): return self.drt
    def set_drt(self, drt): self.drt = drt
    def validate_resourceType(self, value):
        # Validate type resourceType, a restriction on xs:integer.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '20', '21', '22', '23', '10001', '10002', '10003', '10004', '10009', '10010', '10013', '10014', '10016', '10018']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on resourceType' % {"value" : value.encode("utf-8")} )
    def validate_timestamp(self, value):
        # Validate type timestamp, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_timestamp_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_timestamp_patterns_, ))
    validate_timestamp_patterns_ = [['^\\d{4}(0[1-9]|1[0-2])(0[1-9]|[1-2]\\d|30|31)T([01]\\d|2[0-3])[0-5]\\d[0-5]\\d(,\\d{1,6})?$']]
    def validate_absRelTimestamp(self, value):
        # Validate type absRelTimestamp, a restriction on xs:long.
        pass
    def validate_resultContent(self, value):
        # Validate type resultContent, a restriction on xs:integer.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1', '2', '3', '4', '5', '6', '7']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on resultContent' % {"value" : value.encode("utf-8")} )
    def validate_eventCat(self, value):
        # Validate type eventCat, a restriction on xs:integer.
        pass
    def validate_discResType(self, value):
        # Validate type discResType, a restriction on xs:integer.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['1', '2']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on discResType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.ty is not None or
            self.nm is not None or
            self.ot is not None or
            self.rqet is not None or
            self.rset is not None or
            self.oet is not None or
            self.rt is not None or
            self.rp is not None or
            self.rcn is not None or
            self.ec is not None or
            self.da is not None or
            self.gid is not None or
            self.fc is not None or
            self.drt is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='m2m:', name_='metaInformation', namespacedef_='xmlns:m2m="http://www.onem2m.org/xml/protocols"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='metaInformation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='m2m:', name_='metaInformation', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='m2m:', name_='metaInformation'):
        pass
    def exportChildren(self, outfile, level, namespace_='m2m:', name_='metaInformation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ty is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sty>%s</%sty>%s' % (namespace_, self.gds_format_integer(self.ty, input_name='ty'), namespace_, eol_))
        if self.nm is not None:
            self.nm.export(outfile, level, namespace_, name_='nm', pretty_print=pretty_print)
        if self.ot is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sot>%s</%sot>%s' % (namespace_, self.gds_format_string(quote_xml(self.ot).encode(ExternalEncoding), input_name='ot'), namespace_, eol_))
        if self.rqet is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srqet>%s</%srqet>%s' % (namespace_, self.gds_format_integer(self.rqet, input_name='rqet'), namespace_, eol_))
        if self.rset is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srset>%s</%srset>%s' % (namespace_, self.gds_format_integer(self.rset, input_name='rset'), namespace_, eol_))
        if self.oet is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%soet>%s</%soet>%s' % (namespace_, self.gds_format_integer(self.oet, input_name='oet'), namespace_, eol_))
        if self.rt is not None:
            self.rt.export(outfile, level, namespace_, name_='rt', pretty_print=pretty_print)
        if self.rp is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srp>%s</%srp>%s' % (namespace_, self.gds_format_integer(self.rp, input_name='rp'), namespace_, eol_))
        if self.rcn is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srcn>%s</%srcn>%s' % (namespace_, self.gds_format_integer(self.rcn, input_name='rcn'), namespace_, eol_))
        if self.ec is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sec>%s</%sec>%s' % (namespace_, self.gds_format_integer(self.ec, input_name='ec'), namespace_, eol_))
        if self.da is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sda>%s</%sda>%s' % (namespace_, self.gds_format_boolean(self.da, input_name='da'), namespace_, eol_))
        if self.gid is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sgid>%s</%sgid>%s' % (namespace_, self.gds_format_string(quote_xml(self.gid).encode(ExternalEncoding), input_name='gid'), namespace_, eol_))
        if self.fc is not None:
            self.fc.export(outfile, level, namespace_, name_='fc', pretty_print=pretty_print)
        if self.drt is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdrt>%s</%sdrt>%s' % (namespace_, self.gds_format_integer(self.drt, input_name='drt'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ty':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ty')
            self.ty = ival_
            # validate type resourceType
            self.validate_resourceType(self.ty)
        elif nodeName_ == 'nm':
            obj_ = xs_NCName.factory()
            obj_.build(child_)
            self.nm = obj_
            obj_.original_tagname_ = 'nm'
        elif nodeName_ == 'ot':
            ot_ = child_.text
            ot_ = self.gds_validate_string(ot_, node, 'ot')
            self.ot = ot_
            # validate type timestamp
            self.validate_timestamp(self.ot)
        elif nodeName_ == 'rqet':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'rqet')
            self.rqet = ival_
            # validate type absRelTimestamp
            self.validate_absRelTimestamp(self.rqet)
        elif nodeName_ == 'rset':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'rset')
            self.rset = ival_
            # validate type absRelTimestamp
            self.validate_absRelTimestamp(self.rset)
        elif nodeName_ == 'oet':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'oet')
            self.oet = ival_
            # validate type absRelTimestamp
            self.validate_absRelTimestamp(self.oet)
        elif nodeName_ == 'rt':
            obj_ = responseTypeInfo.factory()
            obj_.build(child_)
            self.rt = obj_
            obj_.original_tagname_ = 'rt'
        elif nodeName_ == 'rp':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'rp')
            self.rp = ival_
            # validate type absRelTimestamp
            self.validate_absRelTimestamp(self.rp)
        elif nodeName_ == 'rcn':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'rcn')
            self.rcn = ival_
            # validate type resultContent
            self.validate_resultContent(self.rcn)
        elif nodeName_ == 'ec':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ec')
            self.ec = ival_
            # validate type eventCat
            self.validate_eventCat(self.ec)
        elif nodeName_ == 'da':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'da')
            self.da = ival_
        elif nodeName_ == 'gid':
            gid_ = child_.text
            gid_ = self.gds_validate_string(gid_, node, 'gid')
            self.gid = gid_
        elif nodeName_ == 'fc':
            obj_ = filterCriteria.factory()
            obj_.build(child_)
            self.fc = obj_
            obj_.original_tagname_ = 'fc'
        elif nodeName_ == 'drt':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'drt')
            self.drt = ival_
            # validate type discResType
            self.validate_discResType(self.drt)
# end class metaInformation


class primitiveContent(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, anytypeobjs_=None):
        self.original_tagname_ = None
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if primitiveContent.subclass:
            return primitiveContent.subclass(*args_, **kwargs_)
        else:
            return primitiveContent(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def hasContent_(self):
        if (
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='m2m:', name_='primitiveContent', namespacedef_='xmlns:m2m="http://www.onem2m.org/xml/protocols"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='primitiveContent')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='m2m:', name_='primitiveContent', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='m2m:', name_='primitiveContent'):
        pass
    def exportChildren(self, outfile, level, namespace_='m2m:', name_='primitiveContent', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        obj_ = self.gds_build_any(child_, 'primitiveContent')
        if obj_ is not None:
            self.add_anytypeobjs_(obj_)
# end class primitiveContent


class filterCriteria(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, crb=None, cra=None, ms=None, us=None, sts=None, stb=None, exb=None, exa=None, lbl=None, ty=None, sza=None, szb=None, cty=None, atr=None, fu=None, lim=None):
        self.original_tagname_ = None
        self.crb = crb
        self.validate_timestamp(self.crb)
        self.cra = cra
        self.validate_timestamp(self.cra)
        self.ms = ms
        self.validate_timestamp(self.ms)
        self.us = us
        self.validate_timestamp(self.us)
        self.sts = sts
        self.stb = stb
        self.exb = exb
        self.validate_timestamp(self.exb)
        self.exa = exa
        self.validate_timestamp(self.exa)
        self.lbl = lbl
        self.validate_labels(self.lbl)
        self.ty = ty
        self.validate_resourceType(self.ty)
        self.sza = sza
        self.szb = szb
        if cty is None:
            self.cty = []
        else:
            self.cty = cty
        if atr is None:
            self.atr = []
        else:
            self.atr = atr
        self.fu = fu
        self.validate_filterUsage(self.fu)
        self.lim = lim
    def factory(*args_, **kwargs_):
        if filterCriteria.subclass:
            return filterCriteria.subclass(*args_, **kwargs_)
        else:
            return filterCriteria(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_crb(self): return self.crb
    def set_crb(self, crb): self.crb = crb
    def get_cra(self): return self.cra
    def set_cra(self, cra): self.cra = cra
    def get_ms(self): return self.ms
    def set_ms(self, ms): self.ms = ms
    def get_us(self): return self.us
    def set_us(self, us): self.us = us
    def get_sts(self): return self.sts
    def set_sts(self, sts): self.sts = sts
    def get_stb(self): return self.stb
    def set_stb(self, stb): self.stb = stb
    def get_exb(self): return self.exb
    def set_exb(self, exb): self.exb = exb
    def get_exa(self): return self.exa
    def set_exa(self, exa): self.exa = exa
    def get_lbl(self): return self.lbl
    def set_lbl(self, lbl): self.lbl = lbl
    def get_ty(self): return self.ty
    def set_ty(self, ty): self.ty = ty
    def get_sza(self): return self.sza
    def set_sza(self, sza): self.sza = sza
    def get_szb(self): return self.szb
    def set_szb(self, szb): self.szb = szb
    def get_cty(self): return self.cty
    def set_cty(self, cty): self.cty = cty
    def add_cty(self, value): self.cty.append(value)
    def insert_cty_at(self, index, value): self.cty.insert(index, value)
    def replace_cty_at(self, index, value): self.cty[index] = value
    def get_atr(self): return self.atr
    def set_atr(self, atr): self.atr = atr
    def add_atr(self, value): self.atr.append(value)
    def insert_atr_at(self, index, value): self.atr.insert(index, value)
    def replace_atr_at(self, index, value): self.atr[index] = value
    def get_fu(self): return self.fu
    def set_fu(self, fu): self.fu = fu
    def get_lim(self): return self.lim
    def set_lim(self, lim): self.lim = lim
    def validate_timestamp(self, value):
        # Validate type timestamp, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_timestamp_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_timestamp_patterns_, ))
    validate_timestamp_patterns_ = [['^\\d{4}(0[1-9]|1[0-2])(0[1-9]|[1-2]\\d|30|31)T([01]\\d|2[0-3])[0-5]\\d[0-5]\\d(,\\d{1,6})?$']]
    def validate_labels(self, value):
        # Validate type labels, a restriction on xs:token.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on labels' % {"value" : value} )
    def validate_resourceType(self, value):
        # Validate type resourceType, a restriction on xs:integer.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '20', '21', '22', '23', '10001', '10002', '10003', '10004', '10009', '10010', '10013', '10014', '10016', '10018']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on resourceType' % {"value" : value.encode("utf-8")} )
    def validate_typeOfContent(self, value):
        # Validate type typeOfContent, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_typeOfContent_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_typeOfContent_patterns_, ))
    validate_typeOfContent_patterns_ = [['^[\\w/!#$^_.+&\\-]+$']]
    def validate_filterUsage(self, value):
        # Validate type filterUsage, a restriction on xs:integer.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['1', '2']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on filterUsage' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.crb is not None or
            self.cra is not None or
            self.ms is not None or
            self.us is not None or
            self.sts is not None or
            self.stb is not None or
            self.exb is not None or
            self.exa is not None or
            self.lbl is not None or
            self.ty is not None or
            self.sza is not None or
            self.szb is not None or
            self.cty or
            self.atr or
            self.fu is not None or
            self.lim is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='m2m:', name_='filterCriteria', namespacedef_='xmlns:m2m="http://www.onem2m.org/xml/protocols"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='filterCriteria')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='m2m:', name_='filterCriteria', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='m2m:', name_='filterCriteria'):
        pass
    def exportChildren(self, outfile, level, namespace_='m2m:', name_='filterCriteria', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.crb is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scrb>%s</%scrb>%s' % (namespace_, self.gds_format_string(quote_xml(self.crb).encode(ExternalEncoding), input_name='crb'), namespace_, eol_))
        if self.cra is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scra>%s</%scra>%s' % (namespace_, self.gds_format_string(quote_xml(self.cra).encode(ExternalEncoding), input_name='cra'), namespace_, eol_))
        if self.ms is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sms>%s</%sms>%s' % (namespace_, self.gds_format_string(quote_xml(self.ms).encode(ExternalEncoding), input_name='ms'), namespace_, eol_))
        if self.us is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sus>%s</%sus>%s' % (namespace_, self.gds_format_string(quote_xml(self.us).encode(ExternalEncoding), input_name='us'), namespace_, eol_))
        if self.sts is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssts>%s</%ssts>%s' % (namespace_, self.gds_format_integer(self.sts, input_name='sts'), namespace_, eol_))
        if self.stb is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstb>%s</%sstb>%s' % (namespace_, self.gds_format_integer(self.stb, input_name='stb'), namespace_, eol_))
        if self.exb is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sexb>%s</%sexb>%s' % (namespace_, self.gds_format_string(quote_xml(self.exb).encode(ExternalEncoding), input_name='exb'), namespace_, eol_))
        if self.exa is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sexa>%s</%sexa>%s' % (namespace_, self.gds_format_string(quote_xml(self.exa).encode(ExternalEncoding), input_name='exa'), namespace_, eol_))
        if self.lbl is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slbl>%s</%slbl>%s' % (namespace_, self.gds_format_string(quote_xml(' '.join(self.lbl)).encode(ExternalEncoding), input_name='lbl'), namespace_, eol_))
        if self.ty is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sty>%s</%sty>%s' % (namespace_, self.gds_format_integer(self.ty, input_name='ty'), namespace_, eol_))
        if self.sza is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssza>%s</%ssza>%s' % (namespace_, self.gds_format_integer(self.sza, input_name='sza'), namespace_, eol_))
        if self.szb is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sszb>%s</%sszb>%s' % (namespace_, self.gds_format_integer(self.szb, input_name='szb'), namespace_, eol_))
        for cty_ in self.cty:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scty>%s</%scty>%s' % (namespace_, self.gds_format_string(quote_xml(cty_).encode(ExternalEncoding), input_name='cty'), namespace_, eol_))
        for atr_ in self.atr:
            atr_.export(outfile, level, namespace_, name_='atr', pretty_print=pretty_print)
        if self.fu is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfu>%s</%sfu>%s' % (namespace_, self.gds_format_integer(self.fu, input_name='fu'), namespace_, eol_))
        if self.lim is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slim>%s</%slim>%s' % (namespace_, self.gds_format_integer(self.lim, input_name='lim'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'crb':
            crb_ = child_.text
            crb_ = self.gds_validate_string(crb_, node, 'crb')
            self.crb = crb_
            # validate type timestamp
            self.validate_timestamp(self.crb)
        elif nodeName_ == 'cra':
            cra_ = child_.text
            cra_ = self.gds_validate_string(cra_, node, 'cra')
            self.cra = cra_
            # validate type timestamp
            self.validate_timestamp(self.cra)
        elif nodeName_ == 'ms':
            ms_ = child_.text
            ms_ = self.gds_validate_string(ms_, node, 'ms')
            self.ms = ms_
            # validate type timestamp
            self.validate_timestamp(self.ms)
        elif nodeName_ == 'us':
            us_ = child_.text
            us_ = self.gds_validate_string(us_, node, 'us')
            self.us = us_
            # validate type timestamp
            self.validate_timestamp(self.us)
        elif nodeName_ == 'sts':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'sts')
            self.sts = ival_
        elif nodeName_ == 'stb':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'stb')
            self.stb = ival_
        elif nodeName_ == 'exb':
            exb_ = child_.text
            exb_ = self.gds_validate_string(exb_, node, 'exb')
            self.exb = exb_
            # validate type timestamp
            self.validate_timestamp(self.exb)
        elif nodeName_ == 'exa':
            exa_ = child_.text
            exa_ = self.gds_validate_string(exa_, node, 'exa')
            self.exa = exa_
            # validate type timestamp
            self.validate_timestamp(self.exa)
        elif nodeName_ == 'lbl':
            lbl_ = child_.text
            lbl_ = re_.sub(String_cleanup_pat_, " ", lbl_).strip()
            self.lbl = lbl_
            # validate type labels
            self.validate_labels(self.lbl)
        elif nodeName_ == 'ty':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ty')
            self.ty = ival_
            # validate type resourceType
            self.validate_resourceType(self.ty)
        elif nodeName_ == 'sza':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'sza')
            self.sza = ival_
        elif nodeName_ == 'szb':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'szb')
            self.szb = ival_
        elif nodeName_ == 'cty':
            cty_ = child_.text
            cty_ = self.gds_validate_string(cty_, node, 'cty')
            self.cty.append(cty_)
            # validate type typeOfContent
            self.validate_typeOfContent(self.cty[-1])
        elif nodeName_ == 'atr':
            obj_ = attribute.factory()
            obj_.build(child_)
            self.atr.append(obj_)
            obj_.original_tagname_ = 'atr'
        elif nodeName_ == 'fu':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'fu')
            self.fu = ival_
            # validate type filterUsage
            self.validate_filterUsage(self.fu)
        elif nodeName_ == 'lim':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'lim')
            self.lim = ival_
# end class filterCriteria


class attribute(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nm=None, val=None):
        self.original_tagname_ = None
        self.nm = nm
        self.val = val
    def factory(*args_, **kwargs_):
        if attribute.subclass:
            return attribute.subclass(*args_, **kwargs_)
        else:
            return attribute(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_nm(self): return self.nm
    def set_nm(self, nm): self.nm = nm
    def get_val(self): return self.val
    def set_val(self, val): self.val = val
    def hasContent_(self):
        if (
            self.nm is not None or
            self.val is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='m2m:', name_='attribute', namespacedef_='xmlns:m2m="http://www.onem2m.org/xml/protocols"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='attribute')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='m2m:', name_='attribute', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='m2m:', name_='attribute'):
        pass
    def exportChildren(self, outfile, level, namespace_='m2m:', name_='attribute', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.nm is not None:
            self.nm.export(outfile, level, namespace_, name_='nm', pretty_print=pretty_print)
        if self.val is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sval>%s</%sval>%s' % (namespace_, self.gds_format_string(quote_xml(self.val).encode(ExternalEncoding), input_name='val'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'nm':
            obj_ = xs_NCName.factory()
            obj_.build(child_)
            self.nm = obj_
            obj_.original_tagname_ = 'nm'
        elif nodeName_ == 'val':
            val_ = child_.text
            val_ = self.gds_validate_string(val_, node, 'val')
            self.val = val_
# end class attribute


class scheduleEntries(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, sce=None):
        self.original_tagname_ = None
        if sce is None:
            self.sce = []
        else:
            self.sce = sce
    def factory(*args_, **kwargs_):
        if scheduleEntries.subclass:
            return scheduleEntries.subclass(*args_, **kwargs_)
        else:
            return scheduleEntries(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_sce(self): return self.sce
    def set_sce(self, sce): self.sce = sce
    def add_sce(self, value): self.sce.append(value)
    def insert_sce_at(self, index, value): self.sce.insert(index, value)
    def replace_sce_at(self, index, value): self.sce[index] = value
    def validate_scheduleEntry(self, value):
        # Validate type scheduleEntry, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_scheduleEntry_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_scheduleEntry_patterns_, ))
    validate_scheduleEntry_patterns_ = [['^(([*]|[1-5]?\\d([,-/][1-5]?\\d)*)\\s+){2}([*]|((1?\\d|2[0-3])([,-/](1?\\d|2[0-3]))*))\\s+([*]|(([1-9]|1\\d|2\\d|3[01])([,-/]([1-9]|1\\d|2\\d|3[01]))*))\\s+([*]|(([1-9]|1[0-2])([,-/]([1-9]|1[0-2]))*))\\s+([*]|([0-6]([,-/][0-6])*))\\s+([*]|([2-9]\\d\\d\\d)(([,-]([2-9]\\d\\d\\d)([/][\\d]?[\\d]?[\\d]?[\\d])?)*))$']]
    def hasContent_(self):
        if (
            self.sce
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='m2m:', name_='scheduleEntries', namespacedef_='xmlns:m2m="http://www.onem2m.org/xml/protocols"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='scheduleEntries')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='m2m:', name_='scheduleEntries', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='m2m:', name_='scheduleEntries'):
        pass
    def exportChildren(self, outfile, level, namespace_='m2m:', name_='scheduleEntries', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for sce_ in self.sce:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssce>%s</%ssce>%s' % (namespace_, self.gds_format_string(quote_xml(sce_).encode(ExternalEncoding), input_name='sce'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'sce':
            sce_ = child_.text
            sce_ = self.gds_validate_string(sce_, node, 'sce')
            self.sce.append(sce_)
            # validate type scheduleEntry
            self.validate_scheduleEntry(self.sce[-1])
# end class scheduleEntries


class actionStatus(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, acn=None, sus=None):
        self.original_tagname_ = None
        self.acn = acn
        self.sus = sus
        self.validate_status(self.sus)
    def factory(*args_, **kwargs_):
        if actionStatus.subclass:
            return actionStatus.subclass(*args_, **kwargs_)
        else:
            return actionStatus(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_acn(self): return self.acn
    def set_acn(self, acn): self.acn = acn
    def get_sus(self): return self.sus
    def set_sus(self, sus): self.sus = sus
    def validate_status(self, value):
        # Validate type status, a restriction on xs:integer.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['1', '2', '3']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on status' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.acn is not None or
            self.sus is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='m2m:', name_='actionStatus', namespacedef_='xmlns:m2m="http://www.onem2m.org/xml/protocols"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='actionStatus')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='m2m:', name_='actionStatus', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='m2m:', name_='actionStatus'):
        pass
    def exportChildren(self, outfile, level, namespace_='m2m:', name_='actionStatus', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.acn is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sacn>%s</%sacn>%s' % (namespace_, self.gds_format_string(quote_xml(self.acn).encode(ExternalEncoding), input_name='acn'), namespace_, eol_))
        if self.sus is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssus>%s</%ssus>%s' % (namespace_, self.gds_format_integer(self.sus, input_name='sus'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'acn':
            acn_ = child_.text
            acn_ = self.gds_validate_string(acn_, node, 'acn')
            self.acn = acn_
        elif nodeName_ == 'sus':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'sus')
            self.sus = ival_
            # validate type status
            self.validate_status(self.sus)
# end class actionStatus


class anyArgType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nm=None, val=None):
        self.original_tagname_ = None
        self.nm = nm
        self.val = val
    def factory(*args_, **kwargs_):
        if anyArgType.subclass:
            return anyArgType.subclass(*args_, **kwargs_)
        else:
            return anyArgType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_nm(self): return self.nm
    def set_nm(self, nm): self.nm = nm
    def get_val(self): return self.val
    def set_val(self, val): self.val = val
    def hasContent_(self):
        if (
            self.nm is not None or
            self.val is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='m2m:', name_='anyArgType', namespacedef_='xmlns:m2m="http://www.onem2m.org/xml/protocols"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='anyArgType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='m2m:', name_='anyArgType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='m2m:', name_='anyArgType'):
        pass
    def exportChildren(self, outfile, level, namespace_='m2m:', name_='anyArgType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.nm is not None:
            self.nm.export(outfile, level, namespace_, name_='nm', pretty_print=pretty_print)
        if self.val is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sval>%s</%sval>%s' % (namespace_, self.gds_format_string(quote_xml(self.val).encode(ExternalEncoding), input_name='val'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'nm':
            obj_ = xs_NCName.factory()
            obj_.build(child_)
            self.nm = obj_
            obj_.original_tagname_ = 'nm'
        elif nodeName_ == 'val':
            val_ = child_.text
            val_ = self.gds_validate_string(val_, node, 'val')
            self.val = val_
# end class anyArgType


class resetArgsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, any=None):
        self.original_tagname_ = None
        if any is None:
            self.any = []
        else:
            self.any = any
    def factory(*args_, **kwargs_):
        if resetArgsType.subclass:
            return resetArgsType.subclass(*args_, **kwargs_)
        else:
            return resetArgsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_any(self): return self.any
    def set_any(self, any): self.any = any
    def add_any(self, value): self.any.append(value)
    def insert_any_at(self, index, value): self.any.insert(index, value)
    def replace_any_at(self, index, value): self.any[index] = value
    def hasContent_(self):
        if (
            self.any
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='m2m:', name_='resetArgsType', namespacedef_='xmlns:m2m="http://www.onem2m.org/xml/protocols"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='resetArgsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='m2m:', name_='resetArgsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='m2m:', name_='resetArgsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='m2m:', name_='resetArgsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for any_ in self.any:
            any_.export(outfile, level, namespace_, name_='any', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'any':
            obj_ = anyArgType.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'any'
# end class resetArgsType


class rebootArgsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, any=None):
        self.original_tagname_ = None
        if any is None:
            self.any = []
        else:
            self.any = any
    def factory(*args_, **kwargs_):
        if rebootArgsType.subclass:
            return rebootArgsType.subclass(*args_, **kwargs_)
        else:
            return rebootArgsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_any(self): return self.any
    def set_any(self, any): self.any = any
    def add_any(self, value): self.any.append(value)
    def insert_any_at(self, index, value): self.any.insert(index, value)
    def replace_any_at(self, index, value): self.any[index] = value
    def hasContent_(self):
        if (
            self.any
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='m2m:', name_='rebootArgsType', namespacedef_='xmlns:m2m="http://www.onem2m.org/xml/protocols"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='rebootArgsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='m2m:', name_='rebootArgsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='m2m:', name_='rebootArgsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='m2m:', name_='rebootArgsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for any_ in self.any:
            any_.export(outfile, level, namespace_, name_='any', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'any':
            obj_ = anyArgType.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'any'
# end class rebootArgsType


class uploadArgsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ftyp=None, url=None, unm=None, pwd=None, any=None):
        self.original_tagname_ = None
        self.ftyp = ftyp
        self.url = url
        self.unm = unm
        self.pwd = pwd
        if any is None:
            self.any = []
        else:
            self.any = any
    def factory(*args_, **kwargs_):
        if uploadArgsType.subclass:
            return uploadArgsType.subclass(*args_, **kwargs_)
        else:
            return uploadArgsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ftyp(self): return self.ftyp
    def set_ftyp(self, ftyp): self.ftyp = ftyp
    def get_url(self): return self.url
    def set_url(self, url): self.url = url
    def get_unm(self): return self.unm
    def set_unm(self, unm): self.unm = unm
    def get_pwd(self): return self.pwd
    def set_pwd(self, pwd): self.pwd = pwd
    def get_any(self): return self.any
    def set_any(self, any): self.any = any
    def add_any(self, value): self.any.append(value)
    def insert_any_at(self, index, value): self.any.insert(index, value)
    def replace_any_at(self, index, value): self.any[index] = value
    def hasContent_(self):
        if (
            self.ftyp is not None or
            self.url is not None or
            self.unm is not None or
            self.pwd is not None or
            self.any
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='m2m:', name_='uploadArgsType', namespacedef_='xmlns:m2m="http://www.onem2m.org/xml/protocols"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='uploadArgsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='m2m:', name_='uploadArgsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='m2m:', name_='uploadArgsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='m2m:', name_='uploadArgsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ftyp is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sftyp>%s</%sftyp>%s' % (namespace_, self.gds_format_string(quote_xml(self.ftyp).encode(ExternalEncoding), input_name='ftyp'), namespace_, eol_))
        if self.url is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%surl>%s</%surl>%s' % (namespace_, self.gds_format_string(quote_xml(self.url).encode(ExternalEncoding), input_name='url'), namespace_, eol_))
        if self.unm is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sunm>%s</%sunm>%s' % (namespace_, self.gds_format_string(quote_xml(self.unm).encode(ExternalEncoding), input_name='unm'), namespace_, eol_))
        if self.pwd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spwd>%s</%spwd>%s' % (namespace_, self.gds_format_string(quote_xml(self.pwd).encode(ExternalEncoding), input_name='pwd'), namespace_, eol_))
        for any_ in self.any:
            any_.export(outfile, level, namespace_, name_='any', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ftyp':
            ftyp_ = child_.text
            ftyp_ = self.gds_validate_string(ftyp_, node, 'ftyp')
            self.ftyp = ftyp_
        elif nodeName_ == 'url':
            url_ = child_.text
            url_ = self.gds_validate_string(url_, node, 'url')
            self.url = url_
        elif nodeName_ == 'unm':
            unm_ = child_.text
            unm_ = self.gds_validate_string(unm_, node, 'unm')
            self.unm = unm_
        elif nodeName_ == 'pwd':
            pwd_ = child_.text
            pwd_ = self.gds_validate_string(pwd_, node, 'pwd')
            self.pwd = pwd_
        elif nodeName_ == 'any':
            obj_ = anyArgType.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'any'
# end class uploadArgsType


class downloadArgsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ftyp=None, url=None, unm=None, pwd=None, fsi=None, tgf=None, dss=None, surl=None, stt=None, cpt=None, any=None):
        self.original_tagname_ = None
        self.ftyp = ftyp
        self.url = url
        self.unm = unm
        self.pwd = pwd
        self.fsi = fsi
        self.tgf = tgf
        self.dss = dss
        self.surl = surl
        self.stt = stt
        self.validate_timestamp(self.stt)
        self.cpt = cpt
        self.validate_timestamp(self.cpt)
        if any is None:
            self.any = []
        else:
            self.any = any
    def factory(*args_, **kwargs_):
        if downloadArgsType.subclass:
            return downloadArgsType.subclass(*args_, **kwargs_)
        else:
            return downloadArgsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ftyp(self): return self.ftyp
    def set_ftyp(self, ftyp): self.ftyp = ftyp
    def get_url(self): return self.url
    def set_url(self, url): self.url = url
    def get_unm(self): return self.unm
    def set_unm(self, unm): self.unm = unm
    def get_pwd(self): return self.pwd
    def set_pwd(self, pwd): self.pwd = pwd
    def get_fsi(self): return self.fsi
    def set_fsi(self, fsi): self.fsi = fsi
    def get_tgf(self): return self.tgf
    def set_tgf(self, tgf): self.tgf = tgf
    def get_dss(self): return self.dss
    def set_dss(self, dss): self.dss = dss
    def get_surl(self): return self.surl
    def set_surl(self, surl): self.surl = surl
    def get_stt(self): return self.stt
    def set_stt(self, stt): self.stt = stt
    def get_cpt(self): return self.cpt
    def set_cpt(self, cpt): self.cpt = cpt
    def get_any(self): return self.any
    def set_any(self, any): self.any = any
    def add_any(self, value): self.any.append(value)
    def insert_any_at(self, index, value): self.any.insert(index, value)
    def replace_any_at(self, index, value): self.any[index] = value
    def validate_timestamp(self, value):
        # Validate type timestamp, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_timestamp_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_timestamp_patterns_, ))
    validate_timestamp_patterns_ = [['^\\d{4}(0[1-9]|1[0-2])(0[1-9]|[1-2]\\d|30|31)T([01]\\d|2[0-3])[0-5]\\d[0-5]\\d(,\\d{1,6})?$']]
    def hasContent_(self):
        if (
            self.ftyp is not None or
            self.url is not None or
            self.unm is not None or
            self.pwd is not None or
            self.fsi is not None or
            self.tgf is not None or
            self.dss is not None or
            self.surl is not None or
            self.stt is not None or
            self.cpt is not None or
            self.any
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='m2m:', name_='downloadArgsType', namespacedef_='xmlns:m2m="http://www.onem2m.org/xml/protocols"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='downloadArgsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='m2m:', name_='downloadArgsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='m2m:', name_='downloadArgsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='m2m:', name_='downloadArgsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ftyp is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sftyp>%s</%sftyp>%s' % (namespace_, self.gds_format_string(quote_xml(self.ftyp).encode(ExternalEncoding), input_name='ftyp'), namespace_, eol_))
        if self.url is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%surl>%s</%surl>%s' % (namespace_, self.gds_format_string(quote_xml(self.url).encode(ExternalEncoding), input_name='url'), namespace_, eol_))
        if self.unm is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sunm>%s</%sunm>%s' % (namespace_, self.gds_format_string(quote_xml(self.unm).encode(ExternalEncoding), input_name='unm'), namespace_, eol_))
        if self.pwd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spwd>%s</%spwd>%s' % (namespace_, self.gds_format_string(quote_xml(self.pwd).encode(ExternalEncoding), input_name='pwd'), namespace_, eol_))
        if self.fsi is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfsi>%s</%sfsi>%s' % (namespace_, self.gds_format_integer(self.fsi, input_name='fsi'), namespace_, eol_))
        if self.tgf is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stgf>%s</%stgf>%s' % (namespace_, self.gds_format_string(quote_xml(self.tgf).encode(ExternalEncoding), input_name='tgf'), namespace_, eol_))
        if self.dss is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdss>%s</%sdss>%s' % (namespace_, self.gds_format_integer(self.dss, input_name='dss'), namespace_, eol_))
        if self.surl is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssurl>%s</%ssurl>%s' % (namespace_, self.gds_format_string(quote_xml(self.surl).encode(ExternalEncoding), input_name='surl'), namespace_, eol_))
        if self.stt is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstt>%s</%sstt>%s' % (namespace_, self.gds_format_string(quote_xml(self.stt).encode(ExternalEncoding), input_name='stt'), namespace_, eol_))
        if self.cpt is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scpt>%s</%scpt>%s' % (namespace_, self.gds_format_string(quote_xml(self.cpt).encode(ExternalEncoding), input_name='cpt'), namespace_, eol_))
        for any_ in self.any:
            any_.export(outfile, level, namespace_, name_='any', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ftyp':
            ftyp_ = child_.text
            ftyp_ = self.gds_validate_string(ftyp_, node, 'ftyp')
            self.ftyp = ftyp_
        elif nodeName_ == 'url':
            url_ = child_.text
            url_ = self.gds_validate_string(url_, node, 'url')
            self.url = url_
        elif nodeName_ == 'unm':
            unm_ = child_.text
            unm_ = self.gds_validate_string(unm_, node, 'unm')
            self.unm = unm_
        elif nodeName_ == 'pwd':
            pwd_ = child_.text
            pwd_ = self.gds_validate_string(pwd_, node, 'pwd')
            self.pwd = pwd_
        elif nodeName_ == 'fsi':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'fsi')
            self.fsi = ival_
        elif nodeName_ == 'tgf':
            tgf_ = child_.text
            tgf_ = self.gds_validate_string(tgf_, node, 'tgf')
            self.tgf = tgf_
        elif nodeName_ == 'dss':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'dss')
            self.dss = ival_
        elif nodeName_ == 'surl':
            surl_ = child_.text
            surl_ = self.gds_validate_string(surl_, node, 'surl')
            self.surl = surl_
        elif nodeName_ == 'stt':
            stt_ = child_.text
            stt_ = self.gds_validate_string(stt_, node, 'stt')
            self.stt = stt_
            # validate type timestamp
            self.validate_timestamp(self.stt)
        elif nodeName_ == 'cpt':
            cpt_ = child_.text
            cpt_ = self.gds_validate_string(cpt_, node, 'cpt')
            self.cpt = cpt_
            # validate type timestamp
            self.validate_timestamp(self.cpt)
        elif nodeName_ == 'any':
            obj_ = anyArgType.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'any'
# end class downloadArgsType


class softwareInstallArgsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, url=None, uuid=None, unm=None, pwd=None, eer=None, any=None):
        self.original_tagname_ = None
        self.url = url
        self.uuid = uuid
        self.unm = unm
        self.pwd = pwd
        self.eer = eer
        if any is None:
            self.any = []
        else:
            self.any = any
    def factory(*args_, **kwargs_):
        if softwareInstallArgsType.subclass:
            return softwareInstallArgsType.subclass(*args_, **kwargs_)
        else:
            return softwareInstallArgsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_url(self): return self.url
    def set_url(self, url): self.url = url
    def get_uuid(self): return self.uuid
    def set_uuid(self, uuid): self.uuid = uuid
    def get_unm(self): return self.unm
    def set_unm(self, unm): self.unm = unm
    def get_pwd(self): return self.pwd
    def set_pwd(self, pwd): self.pwd = pwd
    def get_eer(self): return self.eer
    def set_eer(self, eer): self.eer = eer
    def get_any(self): return self.any
    def set_any(self, any): self.any = any
    def add_any(self, value): self.any.append(value)
    def insert_any_at(self, index, value): self.any.insert(index, value)
    def replace_any_at(self, index, value): self.any[index] = value
    def hasContent_(self):
        if (
            self.url is not None or
            self.uuid is not None or
            self.unm is not None or
            self.pwd is not None or
            self.eer is not None or
            self.any
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='m2m:', name_='softwareInstallArgsType', namespacedef_='xmlns:m2m="http://www.onem2m.org/xml/protocols"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='softwareInstallArgsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='m2m:', name_='softwareInstallArgsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='m2m:', name_='softwareInstallArgsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='m2m:', name_='softwareInstallArgsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.url is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%surl>%s</%surl>%s' % (namespace_, self.gds_format_string(quote_xml(self.url).encode(ExternalEncoding), input_name='url'), namespace_, eol_))
        if self.uuid is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%suuid>%s</%suuid>%s' % (namespace_, self.gds_format_string(quote_xml(self.uuid).encode(ExternalEncoding), input_name='uuid'), namespace_, eol_))
        if self.unm is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sunm>%s</%sunm>%s' % (namespace_, self.gds_format_string(quote_xml(self.unm).encode(ExternalEncoding), input_name='unm'), namespace_, eol_))
        if self.pwd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spwd>%s</%spwd>%s' % (namespace_, self.gds_format_string(quote_xml(self.pwd).encode(ExternalEncoding), input_name='pwd'), namespace_, eol_))
        if self.eer is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%seer>%s</%seer>%s' % (namespace_, self.gds_format_string(quote_xml(self.eer).encode(ExternalEncoding), input_name='eer'), namespace_, eol_))
        for any_ in self.any:
            any_.export(outfile, level, namespace_, name_='any', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'url':
            url_ = child_.text
            url_ = self.gds_validate_string(url_, node, 'url')
            self.url = url_
        elif nodeName_ == 'uuid':
            uuid_ = child_.text
            uuid_ = self.gds_validate_string(uuid_, node, 'uuid')
            self.uuid = uuid_
        elif nodeName_ == 'unm':
            unm_ = child_.text
            unm_ = self.gds_validate_string(unm_, node, 'unm')
            self.unm = unm_
        elif nodeName_ == 'pwd':
            pwd_ = child_.text
            pwd_ = self.gds_validate_string(pwd_, node, 'pwd')
            self.pwd = pwd_
        elif nodeName_ == 'eer':
            eer_ = child_.text
            eer_ = self.gds_validate_string(eer_, node, 'eer')
            self.eer = eer_
        elif nodeName_ == 'any':
            obj_ = anyArgType.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'any'
# end class softwareInstallArgsType


class softwareUpdateArgsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uuid=None, vr=None, url=None, unm=None, pwd=None, eer=None, any=None):
        self.original_tagname_ = None
        self.uuid = uuid
        self.vr = vr
        self.url = url
        self.unm = unm
        self.pwd = pwd
        self.eer = eer
        if any is None:
            self.any = []
        else:
            self.any = any
    def factory(*args_, **kwargs_):
        if softwareUpdateArgsType.subclass:
            return softwareUpdateArgsType.subclass(*args_, **kwargs_)
        else:
            return softwareUpdateArgsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uuid(self): return self.uuid
    def set_uuid(self, uuid): self.uuid = uuid
    def get_vr(self): return self.vr
    def set_vr(self, vr): self.vr = vr
    def get_url(self): return self.url
    def set_url(self, url): self.url = url
    def get_unm(self): return self.unm
    def set_unm(self, unm): self.unm = unm
    def get_pwd(self): return self.pwd
    def set_pwd(self, pwd): self.pwd = pwd
    def get_eer(self): return self.eer
    def set_eer(self, eer): self.eer = eer
    def get_any(self): return self.any
    def set_any(self, any): self.any = any
    def add_any(self, value): self.any.append(value)
    def insert_any_at(self, index, value): self.any.insert(index, value)
    def replace_any_at(self, index, value): self.any[index] = value
    def hasContent_(self):
        if (
            self.uuid is not None or
            self.vr is not None or
            self.url is not None or
            self.unm is not None or
            self.pwd is not None or
            self.eer is not None or
            self.any
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='m2m:', name_='softwareUpdateArgsType', namespacedef_='xmlns:m2m="http://www.onem2m.org/xml/protocols"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='softwareUpdateArgsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='m2m:', name_='softwareUpdateArgsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='m2m:', name_='softwareUpdateArgsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='m2m:', name_='softwareUpdateArgsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.uuid is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%suuid>%s</%suuid>%s' % (namespace_, self.gds_format_string(quote_xml(self.uuid).encode(ExternalEncoding), input_name='uuid'), namespace_, eol_))
        if self.vr is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svr>%s</%svr>%s' % (namespace_, self.gds_format_string(quote_xml(self.vr).encode(ExternalEncoding), input_name='vr'), namespace_, eol_))
        if self.url is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%surl>%s</%surl>%s' % (namespace_, self.gds_format_string(quote_xml(self.url).encode(ExternalEncoding), input_name='url'), namespace_, eol_))
        if self.unm is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sunm>%s</%sunm>%s' % (namespace_, self.gds_format_string(quote_xml(self.unm).encode(ExternalEncoding), input_name='unm'), namespace_, eol_))
        if self.pwd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spwd>%s</%spwd>%s' % (namespace_, self.gds_format_string(quote_xml(self.pwd).encode(ExternalEncoding), input_name='pwd'), namespace_, eol_))
        if self.eer is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%seer>%s</%seer>%s' % (namespace_, self.gds_format_string(quote_xml(self.eer).encode(ExternalEncoding), input_name='eer'), namespace_, eol_))
        for any_ in self.any:
            any_.export(outfile, level, namespace_, name_='any', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'uuid':
            uuid_ = child_.text
            uuid_ = self.gds_validate_string(uuid_, node, 'uuid')
            self.uuid = uuid_
        elif nodeName_ == 'vr':
            vr_ = child_.text
            vr_ = self.gds_validate_string(vr_, node, 'vr')
            self.vr = vr_
        elif nodeName_ == 'url':
            url_ = child_.text
            url_ = self.gds_validate_string(url_, node, 'url')
            self.url = url_
        elif nodeName_ == 'unm':
            unm_ = child_.text
            unm_ = self.gds_validate_string(unm_, node, 'unm')
            self.unm = unm_
        elif nodeName_ == 'pwd':
            pwd_ = child_.text
            pwd_ = self.gds_validate_string(pwd_, node, 'pwd')
            self.pwd = pwd_
        elif nodeName_ == 'eer':
            eer_ = child_.text
            eer_ = self.gds_validate_string(eer_, node, 'eer')
            self.eer = eer_
        elif nodeName_ == 'any':
            obj_ = anyArgType.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'any'
# end class softwareUpdateArgsType


class softwareUninstallArgsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uuid=None, vr=None, eer=None, any=None):
        self.original_tagname_ = None
        self.uuid = uuid
        self.vr = vr
        self.eer = eer
        if any is None:
            self.any = []
        else:
            self.any = any
    def factory(*args_, **kwargs_):
        if softwareUninstallArgsType.subclass:
            return softwareUninstallArgsType.subclass(*args_, **kwargs_)
        else:
            return softwareUninstallArgsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uuid(self): return self.uuid
    def set_uuid(self, uuid): self.uuid = uuid
    def get_vr(self): return self.vr
    def set_vr(self, vr): self.vr = vr
    def get_eer(self): return self.eer
    def set_eer(self, eer): self.eer = eer
    def get_any(self): return self.any
    def set_any(self, any): self.any = any
    def add_any(self, value): self.any.append(value)
    def insert_any_at(self, index, value): self.any.insert(index, value)
    def replace_any_at(self, index, value): self.any[index] = value
    def hasContent_(self):
        if (
            self.uuid is not None or
            self.vr is not None or
            self.eer is not None or
            self.any
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='m2m:', name_='softwareUninstallArgsType', namespacedef_='xmlns:m2m="http://www.onem2m.org/xml/protocols"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='softwareUninstallArgsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='m2m:', name_='softwareUninstallArgsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='m2m:', name_='softwareUninstallArgsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='m2m:', name_='softwareUninstallArgsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.uuid is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%suuid>%s</%suuid>%s' % (namespace_, self.gds_format_string(quote_xml(self.uuid).encode(ExternalEncoding), input_name='uuid'), namespace_, eol_))
        if self.vr is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svr>%s</%svr>%s' % (namespace_, self.gds_format_string(quote_xml(self.vr).encode(ExternalEncoding), input_name='vr'), namespace_, eol_))
        if self.eer is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%seer>%s</%seer>%s' % (namespace_, self.gds_format_string(quote_xml(self.eer).encode(ExternalEncoding), input_name='eer'), namespace_, eol_))
        for any_ in self.any:
            any_.export(outfile, level, namespace_, name_='any', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'uuid':
            uuid_ = child_.text
            uuid_ = self.gds_validate_string(uuid_, node, 'uuid')
            self.uuid = uuid_
        elif nodeName_ == 'vr':
            vr_ = child_.text
            vr_ = self.gds_validate_string(vr_, node, 'vr')
            self.vr = vr_
        elif nodeName_ == 'eer':
            eer_ = child_.text
            eer_ = self.gds_validate_string(eer_, node, 'eer')
            self.eer = eer_
        elif nodeName_ == 'any':
            obj_ = anyArgType.factory()
            obj_.build(child_)
            self.any.append(obj_)
            obj_.original_tagname_ = 'any'
# end class softwareUninstallArgsType


class execReqArgsListType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, rst=None, rbo=None, uld=None, dld=None, swin=None, swup=None, swun=None):
        self.original_tagname_ = None
        if rst is None:
            self.rst = []
        else:
            self.rst = rst
        if rbo is None:
            self.rbo = []
        else:
            self.rbo = rbo
        if uld is None:
            self.uld = []
        else:
            self.uld = uld
        if dld is None:
            self.dld = []
        else:
            self.dld = dld
        if swin is None:
            self.swin = []
        else:
            self.swin = swin
        if swup is None:
            self.swup = []
        else:
            self.swup = swup
        if swun is None:
            self.swun = []
        else:
            self.swun = swun
    def factory(*args_, **kwargs_):
        if execReqArgsListType.subclass:
            return execReqArgsListType.subclass(*args_, **kwargs_)
        else:
            return execReqArgsListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_rst(self): return self.rst
    def set_rst(self, rst): self.rst = rst
    def add_rst(self, value): self.rst.append(value)
    def insert_rst_at(self, index, value): self.rst.insert(index, value)
    def replace_rst_at(self, index, value): self.rst[index] = value
    def get_rbo(self): return self.rbo
    def set_rbo(self, rbo): self.rbo = rbo
    def add_rbo(self, value): self.rbo.append(value)
    def insert_rbo_at(self, index, value): self.rbo.insert(index, value)
    def replace_rbo_at(self, index, value): self.rbo[index] = value
    def get_uld(self): return self.uld
    def set_uld(self, uld): self.uld = uld
    def add_uld(self, value): self.uld.append(value)
    def insert_uld_at(self, index, value): self.uld.insert(index, value)
    def replace_uld_at(self, index, value): self.uld[index] = value
    def get_dld(self): return self.dld
    def set_dld(self, dld): self.dld = dld
    def add_dld(self, value): self.dld.append(value)
    def insert_dld_at(self, index, value): self.dld.insert(index, value)
    def replace_dld_at(self, index, value): self.dld[index] = value
    def get_swin(self): return self.swin
    def set_swin(self, swin): self.swin = swin
    def add_swin(self, value): self.swin.append(value)
    def insert_swin_at(self, index, value): self.swin.insert(index, value)
    def replace_swin_at(self, index, value): self.swin[index] = value
    def get_swup(self): return self.swup
    def set_swup(self, swup): self.swup = swup
    def add_swup(self, value): self.swup.append(value)
    def insert_swup_at(self, index, value): self.swup.insert(index, value)
    def replace_swup_at(self, index, value): self.swup[index] = value
    def get_swun(self): return self.swun
    def set_swun(self, swun): self.swun = swun
    def add_swun(self, value): self.swun.append(value)
    def insert_swun_at(self, index, value): self.swun.insert(index, value)
    def replace_swun_at(self, index, value): self.swun[index] = value
    def hasContent_(self):
        if (
            self.rst or
            self.rbo or
            self.uld or
            self.dld or
            self.swin or
            self.swup or
            self.swun
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='m2m:', name_='execReqArgsListType', namespacedef_='xmlns:m2m="http://www.onem2m.org/xml/protocols"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='execReqArgsListType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='m2m:', name_='execReqArgsListType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='m2m:', name_='execReqArgsListType'):
        pass
    def exportChildren(self, outfile, level, namespace_='m2m:', name_='execReqArgsListType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for rst_ in self.rst:
            rst_.export(outfile, level, namespace_, name_='rst', pretty_print=pretty_print)
        for rbo_ in self.rbo:
            rbo_.export(outfile, level, namespace_, name_='rbo', pretty_print=pretty_print)
        for uld_ in self.uld:
            uld_.export(outfile, level, namespace_, name_='uld', pretty_print=pretty_print)
        for dld_ in self.dld:
            dld_.export(outfile, level, namespace_, name_='dld', pretty_print=pretty_print)
        for swin_ in self.swin:
            swin_.export(outfile, level, namespace_, name_='swin', pretty_print=pretty_print)
        for swup_ in self.swup:
            swup_.export(outfile, level, namespace_, name_='swup', pretty_print=pretty_print)
        for swun_ in self.swun:
            swun_.export(outfile, level, namespace_, name_='swun', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'rst':
            obj_ = resetArgsType.factory()
            obj_.build(child_)
            self.rst.append(obj_)
            obj_.original_tagname_ = 'rst'
        elif nodeName_ == 'rbo':
            obj_ = rebootArgsType.factory()
            obj_.build(child_)
            self.rbo.append(obj_)
            obj_.original_tagname_ = 'rbo'
        elif nodeName_ == 'uld':
            obj_ = uploadArgsType.factory()
            obj_.build(child_)
            self.uld.append(obj_)
            obj_.original_tagname_ = 'uld'
        elif nodeName_ == 'dld':
            obj_ = downloadArgsType.factory()
            obj_.build(child_)
            self.dld.append(obj_)
            obj_.original_tagname_ = 'dld'
        elif nodeName_ == 'swin':
            obj_ = softwareInstallArgsType.factory()
            obj_.build(child_)
            self.swin.append(obj_)
            obj_.original_tagname_ = 'swin'
        elif nodeName_ == 'swup':
            obj_ = softwareUpdateArgsType.factory()
            obj_.build(child_)
            self.swup.append(obj_)
            obj_.original_tagname_ = 'swup'
        elif nodeName_ == 'swun':
            obj_ = softwareUninstallArgsType.factory()
            obj_.build(child_)
            self.swun.append(obj_)
            obj_.original_tagname_ = 'swun'
# end class execReqArgsListType


class mgmtLinkRef(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, typ=None, nm=None, valueOf_=None):
        self.original_tagname_ = None
        self.typ = _cast(None, typ)
        self.nm = _cast(None, nm)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if mgmtLinkRef.subclass:
            return mgmtLinkRef.subclass(*args_, **kwargs_)
        else:
            return mgmtLinkRef(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_typ(self): return self.typ
    def set_typ(self, typ): self.typ = typ
    def get_nm(self): return self.nm
    def set_nm(self, nm): self.nm = nm
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='m2m:', name_='mgmtLinkRef', namespacedef_='xmlns:m2m="http://www.onem2m.org/xml/protocols"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='mgmtLinkRef')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else str(self.valueOf_)).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='m2m:', name_='mgmtLinkRef', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='m2m:', name_='mgmtLinkRef'):
        if self.typ is not None and 'typ' not in already_processed:
            already_processed.add('typ')
            outfile.write(' typ=%s' % (quote_attrib(self.typ), ))
        if self.nm is not None and 'nm' not in already_processed:
            already_processed.add('nm')
            outfile.write(' nm=%s' % (quote_attrib(self.nm), ))
    def exportChildren(self, outfile, level, namespace_='m2m:', name_='mgmtLinkRef', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('typ', node)
        if value is not None and 'typ' not in already_processed:
            already_processed.add('typ')
            self.typ = value
        value = find_attr_value_('nm', node)
        if value is not None and 'nm' not in already_processed:
            already_processed.add('nm')
            self.nm = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class mgmtLinkRef


class childResourceRef(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, typ=None, nm=None, valueOf_=None):
        self.original_tagname_ = None
        self.typ = _cast(None, typ)
        self.nm = _cast(None, nm)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if childResourceRef.subclass:
            return childResourceRef.subclass(*args_, **kwargs_)
        else:
            return childResourceRef(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_typ(self): return self.typ
    def set_typ(self, typ): self.typ = typ
    def get_nm(self): return self.nm
    def set_nm(self, nm): self.nm = nm
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            1 if type(self.valueOf_) in [int,float] else self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='m2m:', name_='childResourceRef', namespacedef_='xmlns:m2m="http://www.onem2m.org/xml/protocols"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='childResourceRef')
        if self.hasContent_():
            outfile.write('>')
            outfile.write((quote_xml(self.valueOf_) if type(self.valueOf_) is str else str(self.valueOf_)).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='m2m:', name_='childResourceRef', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='m2m:', name_='childResourceRef'):
        if self.typ is not None and 'typ' not in already_processed:
            already_processed.add('typ')
            outfile.write(' typ=%s' % (quote_attrib(self.typ), ))
        if self.nm is not None and 'nm' not in already_processed:
            already_processed.add('nm')
            outfile.write(' nm=%s' % (quote_attrib(self.nm), ))
    def exportChildren(self, outfile, level, namespace_='m2m:', name_='childResourceRef', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('typ', node)
        if value is not None and 'typ' not in already_processed:
            already_processed.add('typ')
            self.typ = value
        value = find_attr_value_('nm', node)
        if value is not None and 'nm' not in already_processed:
            already_processed.add('nm')
            self.nm = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class childResourceRef


class responseTypeInfo(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, rtv=None, nu=None):
        self.original_tagname_ = None
        self.rtv = rtv
        self.validate_responseType(self.rtv)
        self.nu = nu
        self.validate_nuType(self.nu)
    def factory(*args_, **kwargs_):
        if responseTypeInfo.subclass:
            return responseTypeInfo.subclass(*args_, **kwargs_)
        else:
            return responseTypeInfo(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_rtv(self): return self.rtv
    def set_rtv(self, rtv): self.rtv = rtv
    def get_nu(self): return self.nu
    def set_nu(self, nu): self.nu = nu
    def validate_responseType(self, value):
        # Validate type responseType, a restriction on xs:integer.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['1', '2', '3']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on responseType' % {"value" : value.encode("utf-8")} )
    def validate_nuType(self, value):
        # Validate type nuType, a restriction on xs:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on nuType' % {"value" : value} )
    def hasContent_(self):
        if (
            self.rtv is not None or
            self.nu is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='m2m:', name_='responseTypeInfo', namespacedef_='xmlns:m2m="http://www.onem2m.org/xml/protocols"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='responseTypeInfo')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='m2m:', name_='responseTypeInfo', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='m2m:', name_='responseTypeInfo'):
        pass
    def exportChildren(self, outfile, level, namespace_='m2m:', name_='responseTypeInfo', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.rtv is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srtv>%s</%srtv>%s' % (namespace_, self.gds_format_integer(self.rtv, input_name='rtv'), namespace_, eol_))
        if self.nu is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snu>%s</%snu>%s' % (namespace_, self.gds_format_string(quote_xml(' '.join(self.nu)).encode(ExternalEncoding), input_name='nu'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'rtv':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'rtv')
            self.rtv = ival_
            # validate type responseType
            self.validate_responseType(self.rtv)
        elif nodeName_ == 'nu':
            nu_ = child_.text
            self.nu = nu_
            # validate type nuType
            self.validate_nuType(self.nu)
# end class responseTypeInfo


class operationResult(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, rsc=None, rqi=None, pc=None, to=None, fr=None, ot=None, rset=None, ec=None):
        self.original_tagname_ = None
        self.rsc = rsc
        self.validate_responseStatusCode(self.rsc)
        self.rqi = rqi
        self.validate_requestID(self.rqi)
        self.pc = pc
        self.to = to
        self.fr = fr
        self.validate_ID(self.fr)
        self.ot = ot
        self.validate_timestamp(self.ot)
        self.rset = rset
        self.validate_absRelTimestamp(self.rset)
        self.ec = ec
        self.validate_eventCat(self.ec)
    def factory(*args_, **kwargs_):
        if operationResult.subclass:
            return operationResult.subclass(*args_, **kwargs_)
        else:
            return operationResult(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_rsc(self): return self.rsc
    def set_rsc(self, rsc): self.rsc = rsc
    def get_rqi(self): return self.rqi
    def set_rqi(self, rqi): self.rqi = rqi
    def get_pc(self): return self.pc
    def set_pc(self, pc): self.pc = pc
    def get_to(self): return self.to
    def set_to(self, to): self.to = to
    def get_fr(self): return self.fr
    def set_fr(self, fr): self.fr = fr
    def get_ot(self): return self.ot
    def set_ot(self, ot): self.ot = ot
    def get_rset(self): return self.rset
    def set_rset(self, rset): self.rset = rset
    def get_ec(self): return self.ec
    def set_ec(self, ec): self.ec = ec
    def validate_responseStatusCode(self, value):
        # Validate type responseStatusCode, a restriction on xs:integer.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['1000', '2000', '2001', '2002', '2004', '4000', '4004', '4005', '4008', '4101', '4102', '4103', '4104', '4105', '5000', '5001', '5103', '5105', '5106', '5203', '5204', '5205', '5206', '5207', '6003', '6005', '6010', '6011', '6020', '6021', '6022', '6023', '6024', '6025', '6026', '6028', '6029']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on responseStatusCode' % {"value" : value.encode("utf-8")} )
    def validate_requestID(self, value):
        # Validate type requestID, a restriction on xs:token.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_ID(self, value):
        # Validate type ID, a restriction on xs:anyURI.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_timestamp(self, value):
        # Validate type timestamp, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_timestamp_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_timestamp_patterns_, ))
    validate_timestamp_patterns_ = [['^\\d{4}(0[1-9]|1[0-2])(0[1-9]|[1-2]\\d|30|31)T([01]\\d|2[0-3])[0-5]\\d[0-5]\\d(,\\d{1,6})?$']]
    def validate_absRelTimestamp(self, value):
        # Validate type absRelTimestamp, a restriction on xs:long.
        pass
    def validate_eventCat(self, value):
        # Validate type eventCat, a restriction on xs:integer.
        pass
    def hasContent_(self):
        if (
            self.rsc is not None or
            self.rqi is not None or
            self.pc is not None or
            self.to is not None or
            self.fr is not None or
            self.ot is not None or
            self.rset is not None or
            self.ec is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='m2m:', name_='operationResult', namespacedef_='xmlns:m2m="http://www.onem2m.org/xml/protocols"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='operationResult')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='m2m:', name_='operationResult', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='m2m:', name_='operationResult'):
        pass
    def exportChildren(self, outfile, level, namespace_='m2m:', name_='operationResult', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.rsc is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srsc>%s</%srsc>%s' % (namespace_, self.gds_format_integer(self.rsc, input_name='rsc'), namespace_, eol_))
        if self.rqi is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srqi>%s</%srqi>%s' % (namespace_, self.gds_format_string(quote_xml(self.rqi).encode(ExternalEncoding), input_name='rqi'), namespace_, eol_))
        if self.pc is not None:
            self.pc.export(outfile, level, namespace_, name_='pc', pretty_print=pretty_print)
        if self.to is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sto>%s</%sto>%s' % (namespace_, self.gds_format_string(quote_xml(self.to).encode(ExternalEncoding), input_name='to'), namespace_, eol_))
        if self.fr is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfr>%s</%sfr>%s' % (namespace_, self.gds_format_string(quote_xml(self.fr).encode(ExternalEncoding), input_name='fr'), namespace_, eol_))
        if self.ot is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sot>%s</%sot>%s' % (namespace_, self.gds_format_string(quote_xml(self.ot).encode(ExternalEncoding), input_name='ot'), namespace_, eol_))
        if self.rset is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srset>%s</%srset>%s' % (namespace_, self.gds_format_integer(self.rset, input_name='rset'), namespace_, eol_))
        if self.ec is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sec>%s</%sec>%s' % (namespace_, self.gds_format_integer(self.ec, input_name='ec'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'rsc':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'rsc')
            self.rsc = ival_
            # validate type responseStatusCode
            self.validate_responseStatusCode(self.rsc)
        elif nodeName_ == 'rqi':
            rqi_ = child_.text
            rqi_ = re_.sub(String_cleanup_pat_, " ", rqi_).strip()
            rqi_ = self.gds_validate_string(rqi_, node, 'rqi')
            self.rqi = rqi_
            # validate type requestID
            self.validate_requestID(self.rqi)
        elif nodeName_ == 'pc':
            obj_ = primitiveContent.factory()
            obj_.build(child_)
            self.pc = obj_
            obj_.original_tagname_ = 'pc'
        elif nodeName_ == 'to':
            to_ = child_.text
            to_ = self.gds_validate_string(to_, node, 'to')
            self.to = to_
        elif nodeName_ == 'fr':
            fr_ = child_.text
            fr_ = self.gds_validate_string(fr_, node, 'fr')
            self.fr = fr_
            # validate type ID
            self.validate_ID(self.fr)
        elif nodeName_ == 'ot':
            ot_ = child_.text
            ot_ = self.gds_validate_string(ot_, node, 'ot')
            self.ot = ot_
            # validate type timestamp
            self.validate_timestamp(self.ot)
        elif nodeName_ == 'rset':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'rset')
            self.rset = ival_
            # validate type absRelTimestamp
            self.validate_absRelTimestamp(self.rset)
        elif nodeName_ == 'ec':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ec')
            self.ec = ival_
            # validate type eventCat
            self.validate_eventCat(self.ec)
# end class operationResult


class resource(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, rn=None, ty=None, ri=None, pi=None, ct=None, lt=None, lbl=None, extensiontype_=None):
        self.original_tagname_ = None
        self.rn = _cast(None, rn)
        self.ty = ty
        self.validate_resourceType(self.ty)
        self.ri = ri
        self.validate_ID(self.ri)
        self.pi = pi
        self.validate_nhURI(self.pi)
        self.ct = ct
        self.validate_timestamp(self.ct)
        self.lt = lt
        self.validate_timestamp(self.lt)
        self.lbl = lbl
        self.validate_labels(self.lbl)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if resource.subclass:
            return resource.subclass(*args_, **kwargs_)
        else:
            return resource(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ty(self): return self.ty
    def set_ty(self, ty): self.ty = ty
    def get_ri(self): return self.ri
    def set_ri(self, ri): self.ri = ri
    def get_pi(self): return self.pi
    def set_pi(self, pi): self.pi = pi
    def get_ct(self): return self.ct
    def set_ct(self, ct): self.ct = ct
    def get_lt(self): return self.lt
    def set_lt(self, lt): self.lt = lt
    def get_lbl(self): return self.lbl
    def set_lbl(self, lbl): self.lbl = lbl
    def get_rn(self): return self.rn
    def set_rn(self, rn): self.rn = rn
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_resourceType(self, value):
        # Validate type resourceType, a restriction on xs:integer.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '20', '21', '22', '23', '10001', '10002', '10003', '10004', '10009', '10010', '10013', '10014', '10016', '10018']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on resourceType' % {"value" : value.encode("utf-8")} )
    def validate_ID(self, value):
        # Validate type ID, a restriction on xs:anyURI.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_nhURI(self, value):
        # Validate type nhURI, a restriction on xs:anyURI.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_timestamp(self, value):
        # Validate type timestamp, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_timestamp_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_timestamp_patterns_, ))
    validate_timestamp_patterns_ = [['^\\d{4}(0[1-9]|1[0-2])(0[1-9]|[1-2]\\d|30|31)T([01]\\d|2[0-3])[0-5]\\d[0-5]\\d(,\\d{1,6})?$']]
    def validate_labels(self, value):
        # Validate type labels, a restriction on xs:token.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on labels' % {"value" : value} )
    def hasContent_(self):
        if (
            self.ty is not None or
            self.ri is not None or
            self.pi is not None or
            self.ct is not None or
            self.lt is not None or
            self.lbl is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='m2m:', name_='resource', namespacedef_='xmlns:m2m="http://www.onem2m.org/xml/protocols"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='resource')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='m2m:', name_='resource', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='m2m:', name_='resource'):
        if self.rn is not None and 'rn' not in already_processed:
            already_processed.add('rn')
            outfile.write(' rn=%s' % (quote_attrib(self.rn), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='m2m:', name_='resource', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ty is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sty>%s</%sty>%s' % (namespace_, self.gds_format_integer(self.ty, input_name='ty'), namespace_, eol_))
        if self.ri is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sri>%s</%sri>%s' % (namespace_, self.gds_format_string(quote_xml(self.ri).encode(ExternalEncoding), input_name='ri'), namespace_, eol_))
        if self.pi is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spi>%s</%spi>%s' % (namespace_, self.gds_format_string(quote_xml(self.pi).encode(ExternalEncoding), input_name='pi'), namespace_, eol_))
        if self.ct is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sct>%s</%sct>%s' % (namespace_, self.gds_format_string(quote_xml(self.ct).encode(ExternalEncoding), input_name='ct'), namespace_, eol_))
        if self.lt is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slt>%s</%slt>%s' % (namespace_, self.gds_format_string(quote_xml(self.lt).encode(ExternalEncoding), input_name='lt'), namespace_, eol_))
        if self.lbl is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slbl>%s</%slbl>%s' % (namespace_, self.gds_format_string(quote_xml(' '.join(self.lbl)).encode(ExternalEncoding), input_name='lbl'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('rn', node)
        if value is not None and 'rn' not in already_processed:
            already_processed.add('rn')
            self.rn = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ty':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ty')
            self.ty = ival_
            # validate type resourceType
            self.validate_resourceType(self.ty)
        elif nodeName_ == 'ri':
            ri_ = child_.text
            ri_ = self.gds_validate_string(ri_, node, 'ri')
            self.ri = ri_
            # validate type ID
            self.validate_ID(self.ri)
        elif nodeName_ == 'pi':
            pi_ = child_.text
            pi_ = self.gds_validate_string(pi_, node, 'pi')
            self.pi = pi_
            # validate type nhURI
            self.validate_nhURI(self.pi)
        elif nodeName_ == 'ct':
            ct_ = child_.text
            ct_ = self.gds_validate_string(ct_, node, 'ct')
            self.ct = ct_
            # validate type timestamp
            self.validate_timestamp(self.ct)
        elif nodeName_ == 'lt':
            lt_ = child_.text
            lt_ = self.gds_validate_string(lt_, node, 'lt')
            self.lt = lt_
            # validate type timestamp
            self.validate_timestamp(self.lt)
        elif nodeName_ == 'lbl':
            lbl_ = child_.text
            lbl_ = re_.sub(String_cleanup_pat_, " ", lbl_).strip()
            self.lbl = lbl_
            # validate type labels
            self.validate_labels(self.lbl)
# end class resource


class regularResource(resource):
    subclass = None
    superclass = resource
    def __init__(self, rn=None, ty=None, ri=None, pi=None, ct=None, lt=None, lbl=None, acpi=None, et=None, extensiontype_=None):
        self.original_tagname_ = None
        super(regularResource, self).__init__(rn, ty, ri, pi, ct, lt, lbl, extensiontype_, )
        self.acpi = acpi
        self.validate_acpType(self.acpi)
        self.et = et
        self.validate_timestamp(self.et)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if regularResource.subclass:
            return regularResource.subclass(*args_, **kwargs_)
        else:
            return regularResource(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_acpi(self): return self.acpi
    def set_acpi(self, acpi): self.acpi = acpi
    def get_et(self): return self.et
    def set_et(self, et): self.et = et
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_acpType(self, value):
        # Validate type acpType, a restriction on m2m:ID.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on acpType' % {"value" : value} )
    def validate_timestamp(self, value):
        # Validate type timestamp, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_timestamp_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_timestamp_patterns_, ))
    validate_timestamp_patterns_ = [['^\\d{4}(0[1-9]|1[0-2])(0[1-9]|[1-2]\\d|30|31)T([01]\\d|2[0-3])[0-5]\\d[0-5]\\d(,\\d{1,6})?$']]
    def hasContent_(self):
        if (
            self.acpi is not None or
            self.et is not None or
            super(regularResource, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='m2m:', name_='regularResource', namespacedef_='xmlns:m2m="http://www.onem2m.org/xml/protocols"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='regularResource')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='m2m:', name_='regularResource', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='m2m:', name_='regularResource'):
        super(regularResource, self).exportAttributes(outfile, level, already_processed, namespace_, name_='regularResource')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='m2m:', name_='regularResource', fromsubclass_=False, pretty_print=True):
        super(regularResource, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.acpi is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sacpi>%s</%sacpi>%s' % (namespace_, self.gds_format_string(quote_xml(' '.join(self.acpi)).encode(ExternalEncoding), input_name='acpi'), namespace_, eol_))
        if self.et is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%set>%s</%set>%s' % (namespace_, self.gds_format_string(quote_xml(self.et).encode(ExternalEncoding), input_name='et'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(regularResource, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'acpi':
            acpi_ = child_.text
            self.acpi = acpi_
            # validate type acpType
            self.validate_acpType(self.acpi)
        elif nodeName_ == 'et':
            et_ = child_.text
            et_ = self.gds_validate_string(et_, node, 'et')
            self.et = et_
            # validate type timestamp
            self.validate_timestamp(self.et)
        super(regularResource, self).buildChildren(child_, node, nodeName_, True)
# end class regularResource


class announceableResource(regularResource):
    subclass = None
    superclass = regularResource
    def __init__(self, rn=None, ty=None, ri=None, pi=None, ct=None, lt=None, lbl=None, acpi=None, et=None, at=None, aa=None, extensiontype_=None):
        self.original_tagname_ = None
        super(announceableResource, self).__init__(rn, ty, ri, pi, ct, lt, lbl, acpi, et, extensiontype_, )
        self.at = at
        self.validate_listOfURIs(self.at)
        self.aa = aa
        self.validate_aaType(self.aa)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if announceableResource.subclass:
            return announceableResource.subclass(*args_, **kwargs_)
        else:
            return announceableResource(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_at(self): return self.at
    def set_at(self, at): self.at = at
    def get_aa(self): return self.aa
    def set_aa(self, aa): self.aa = aa
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_listOfURIs(self, value):
        # Validate type listOfURIs, a restriction on xs:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on listOfURIs' % {"value" : value} )
    def validate_aaType(self, value):
        # Validate type aaType, a restriction on xs:NCName.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on aaType' % {"value" : value} )
    def hasContent_(self):
        if (
            self.at is not None or
            self.aa is not None or
            super(announceableResource, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='m2m:', name_='announceableResource', namespacedef_='xmlns:m2m="http://www.onem2m.org/xml/protocols"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='announceableResource')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='m2m:', name_='announceableResource', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='m2m:', name_='announceableResource'):
        super(announceableResource, self).exportAttributes(outfile, level, already_processed, namespace_, name_='announceableResource')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='m2m:', name_='announceableResource', fromsubclass_=False, pretty_print=True):
        super(announceableResource, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.at is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sat>%s</%sat>%s' % (namespace_, self.gds_format_string(quote_xml(' '.join(self.at)).encode(ExternalEncoding), input_name='at'), namespace_, eol_))
        if self.aa is not None:
            self.aa.export(outfile, level, namespace_, name_='aa', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(announceableResource, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'at':
            at_ = child_.text
            self.at = at_
            # validate type listOfURIs
            self.validate_listOfURIs(self.at)
        elif nodeName_ == 'aa':
            aa_ = child_.text
            self.aa = aa_
            # validate type aaType
            self.validate_aaType(self.aa)
        super(announceableResource, self).buildChildren(child_, node, nodeName_, True)
# end class announceableResource


class announcedResource(resource):
    subclass = None
    superclass = resource
    def __init__(self, rn=None, ty=None, ri=None, pi=None, ct=None, lt=None, lbl=None, acpi=None, et=None, lnk=None, extensiontype_=None):
        self.original_tagname_ = None
        super(announcedResource, self).__init__(rn, ty, ri, pi, ct, lt, lbl, extensiontype_, )
        self.acpi = acpi
        self.validate_acpType(self.acpi)
        self.et = et
        self.validate_timestamp(self.et)
        self.lnk = lnk
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if announcedResource.subclass:
            return announcedResource.subclass(*args_, **kwargs_)
        else:
            return announcedResource(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_acpi(self): return self.acpi
    def set_acpi(self, acpi): self.acpi = acpi
    def get_et(self): return self.et
    def set_et(self, et): self.et = et
    def get_lnk(self): return self.lnk
    def set_lnk(self, lnk): self.lnk = lnk
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_acpType(self, value):
        # Validate type acpType, a restriction on m2m:ID.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on acpType' % {"value" : value} )
    def validate_timestamp(self, value):
        # Validate type timestamp, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_timestamp_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_timestamp_patterns_, ))
    validate_timestamp_patterns_ = [['^\\d{4}(0[1-9]|1[0-2])(0[1-9]|[1-2]\\d|30|31)T([01]\\d|2[0-3])[0-5]\\d[0-5]\\d(,\\d{1,6})?$']]
    def hasContent_(self):
        if (
            self.acpi is not None or
            self.et is not None or
            self.lnk is not None or
            super(announcedResource, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='m2m:', name_='announcedResource', namespacedef_='xmlns:m2m="http://www.onem2m.org/xml/protocols"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='announcedResource')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='m2m:', name_='announcedResource', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='m2m:', name_='announcedResource'):
        super(announcedResource, self).exportAttributes(outfile, level, already_processed, namespace_, name_='announcedResource')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='m2m:', name_='announcedResource', fromsubclass_=False, pretty_print=True):
        super(announcedResource, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.acpi is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sacpi>%s</%sacpi>%s' % (namespace_, self.gds_format_string(quote_xml(' '.join(self.acpi)).encode(ExternalEncoding), input_name='acpi'), namespace_, eol_))
        if self.et is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%set>%s</%set>%s' % (namespace_, self.gds_format_string(quote_xml(self.et).encode(ExternalEncoding), input_name='et'), namespace_, eol_))
        if self.lnk is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slnk>%s</%slnk>%s' % (namespace_, self.gds_format_string(quote_xml(self.lnk).encode(ExternalEncoding), input_name='lnk'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(announcedResource, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'acpi':
            acpi_ = child_.text
            self.acpi = acpi_
            # validate type acpType
            self.validate_acpType(self.acpi)
        elif nodeName_ == 'et':
            et_ = child_.text
            et_ = self.gds_validate_string(et_, node, 'et')
            self.et = et_
            # validate type timestamp
            self.validate_timestamp(self.et)
        elif nodeName_ == 'lnk':
            lnk_ = child_.text
            lnk_ = self.gds_validate_string(lnk_, node, 'lnk')
            self.lnk = lnk_
        super(announcedResource, self).buildChildren(child_, node, nodeName_, True)
# end class announcedResource


class announceableSubordinateResource(resource):
    subclass = None
    superclass = resource
    def __init__(self, rn=None, ty=None, ri=None, pi=None, ct=None, lt=None, lbl=None, et=None, at=None, aa=None, extensiontype_=None):
        self.original_tagname_ = None
        super(announceableSubordinateResource, self).__init__(rn, ty, ri, pi, ct, lt, lbl, extensiontype_, )
        self.et = et
        self.validate_timestamp(self.et)
        self.at = at
        self.validate_listOfURIs(self.at)
        self.aa = aa
        self.validate_aaType1(self.aa)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if announceableSubordinateResource.subclass:
            return announceableSubordinateResource.subclass(*args_, **kwargs_)
        else:
            return announceableSubordinateResource(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_et(self): return self.et
    def set_et(self, et): self.et = et
    def get_at(self): return self.at
    def set_at(self, at): self.at = at
    def get_aa(self): return self.aa
    def set_aa(self, aa): self.aa = aa
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_timestamp(self, value):
        # Validate type timestamp, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_timestamp_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_timestamp_patterns_, ))
    validate_timestamp_patterns_ = [['^\\d{4}(0[1-9]|1[0-2])(0[1-9]|[1-2]\\d|30|31)T([01]\\d|2[0-3])[0-5]\\d[0-5]\\d(,\\d{1,6})?$']]
    def validate_listOfURIs(self, value):
        # Validate type listOfURIs, a restriction on xs:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on listOfURIs' % {"value" : value} )
    def validate_aaType1(self, value):
        # Validate type aaType1, a restriction on xs:NCName.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on aaType1' % {"value" : value} )
    def hasContent_(self):
        if (
            self.et is not None or
            self.at is not None or
            self.aa is not None or
            super(announceableSubordinateResource, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='m2m:', name_='announceableSubordinateResource', namespacedef_='xmlns:m2m="http://www.onem2m.org/xml/protocols"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='announceableSubordinateResource')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='m2m:', name_='announceableSubordinateResource', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='m2m:', name_='announceableSubordinateResource'):
        super(announceableSubordinateResource, self).exportAttributes(outfile, level, already_processed, namespace_, name_='announceableSubordinateResource')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='m2m:', name_='announceableSubordinateResource', fromsubclass_=False, pretty_print=True):
        super(announceableSubordinateResource, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.et is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%set>%s</%set>%s' % (namespace_, self.gds_format_string(quote_xml(self.et).encode(ExternalEncoding), input_name='et'), namespace_, eol_))
        if self.at is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sat>%s</%sat>%s' % (namespace_, self.gds_format_string(quote_xml(' '.join(self.at)).encode(ExternalEncoding), input_name='at'), namespace_, eol_))
        if self.aa is not None:
            self.aa.export(outfile, level, namespace_, name_='aa', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(announceableSubordinateResource, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'et':
            et_ = child_.text
            et_ = self.gds_validate_string(et_, node, 'et')
            self.et = et_
            # validate type timestamp
            self.validate_timestamp(self.et)
        elif nodeName_ == 'at':
            at_ = child_.text
            self.at = at_
            # validate type listOfURIs
            self.validate_listOfURIs(self.at)
        elif nodeName_ == 'aa':
            aa_ = child_.text
            self.aa = aa_
            # validate type aaType1
            self.validate_aaType1(self.aa)
        super(announceableSubordinateResource, self).buildChildren(child_, node, nodeName_, True)
# end class announceableSubordinateResource


class announcedSubordinateResource(resource):
    subclass = None
    superclass = resource
    def __init__(self, rn=None, ty=None, ri=None, pi=None, ct=None, lt=None, lbl=None, et=None, lnk=None, extensiontype_=None):
        self.original_tagname_ = None
        super(announcedSubordinateResource, self).__init__(rn, ty, ri, pi, ct, lt, lbl, extensiontype_, )
        self.et = et
        self.validate_timestamp(self.et)
        self.lnk = lnk
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if announcedSubordinateResource.subclass:
            return announcedSubordinateResource.subclass(*args_, **kwargs_)
        else:
            return announcedSubordinateResource(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_et(self): return self.et
    def set_et(self, et): self.et = et
    def get_lnk(self): return self.lnk
    def set_lnk(self, lnk): self.lnk = lnk
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_timestamp(self, value):
        # Validate type timestamp, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_timestamp_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_timestamp_patterns_, ))
    validate_timestamp_patterns_ = [['^\\d{4}(0[1-9]|1[0-2])(0[1-9]|[1-2]\\d|30|31)T([01]\\d|2[0-3])[0-5]\\d[0-5]\\d(,\\d{1,6})?$']]
    def hasContent_(self):
        if (
            self.et is not None or
            self.lnk is not None or
            super(announcedSubordinateResource, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='m2m:', name_='announcedSubordinateResource', namespacedef_='xmlns:m2m="http://www.onem2m.org/xml/protocols"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='announcedSubordinateResource')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='m2m:', name_='announcedSubordinateResource', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='m2m:', name_='announcedSubordinateResource'):
        super(announcedSubordinateResource, self).exportAttributes(outfile, level, already_processed, namespace_, name_='announcedSubordinateResource')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='m2m:', name_='announcedSubordinateResource', fromsubclass_=False, pretty_print=True):
        super(announcedSubordinateResource, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.et is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%set>%s</%set>%s' % (namespace_, self.gds_format_string(quote_xml(self.et).encode(ExternalEncoding), input_name='et'), namespace_, eol_))
        if self.lnk is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slnk>%s</%slnk>%s' % (namespace_, self.gds_format_string(quote_xml(self.lnk).encode(ExternalEncoding), input_name='lnk'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(announcedSubordinateResource, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'et':
            et_ = child_.text
            et_ = self.gds_validate_string(et_, node, 'et')
            self.et = et_
            # validate type timestamp
            self.validate_timestamp(self.et)
        elif nodeName_ == 'lnk':
            lnk_ = child_.text
            lnk_ = self.gds_validate_string(lnk_, node, 'lnk')
            self.lnk = lnk_
        super(announcedSubordinateResource, self).buildChildren(child_, node, nodeName_, True)
# end class announcedSubordinateResource


class mgmtResource(announceableResource):
    subclass = None
    superclass = announceableResource
    def __init__(self, rn=None, ty=None, ri=None, pi=None, ct=None, lt=None, lbl=None, acpi=None, et=None, at=None, aa=None, mgd=None, obis=None, obps=None, dc=None):
        self.original_tagname_ = None
        super(mgmtResource, self).__init__(rn, ty, ri, pi, ct, lt, lbl, acpi, et, at, aa, )
        self.mgd = mgd
        self.validate_mgmtDefinition(self.mgd)
        self.obis = obis
        self.validate_listOfURIs(self.obis)
        self.obps = obps
        self.validate_listOfURIs(self.obps)
        self.dc = dc
    def factory(*args_, **kwargs_):
        if mgmtResource.subclass:
            return mgmtResource.subclass(*args_, **kwargs_)
        else:
            return mgmtResource(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_mgd(self): return self.mgd
    def set_mgd(self, mgd): self.mgd = mgd
    def get_obis(self): return self.obis
    def set_obis(self, obis): self.obis = obis
    def get_obps(self): return self.obps
    def set_obps(self, obps): self.obps = obps
    def get_dc(self): return self.dc
    def set_dc(self, dc): self.dc = dc
    def validate_mgmtDefinition(self, value):
        # Validate type mgmtDefinition, a restriction on xs:integer.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1001', '1002', '1003', '1004', '1005', '1006', '1007', '1008', '1009', '1010', '1011', '1012', '1013', '1014', '1015', '1016', '1017', '1018', '1019']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on mgmtDefinition' % {"value" : value.encode("utf-8")} )
    def validate_listOfURIs(self, value):
        # Validate type listOfURIs, a restriction on xs:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on listOfURIs' % {"value" : value} )
    def hasContent_(self):
        if (
            self.mgd is not None or
            self.obis is not None or
            self.obps is not None or
            self.dc is not None or
            super(mgmtResource, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='m2m:', name_='mgmtResource', namespacedef_='xmlns:m2m="http://www.onem2m.org/xml/protocols"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='mgmtResource')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='m2m:', name_='mgmtResource', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='m2m:', name_='mgmtResource'):
        super(mgmtResource, self).exportAttributes(outfile, level, already_processed, namespace_, name_='mgmtResource')
    def exportChildren(self, outfile, level, namespace_='m2m:', name_='mgmtResource', fromsubclass_=False, pretty_print=True):
        super(mgmtResource, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.mgd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smgd>%s</%smgd>%s' % (namespace_, self.gds_format_integer(self.mgd, input_name='mgd'), namespace_, eol_))
        if self.obis is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sobis>%s</%sobis>%s' % (namespace_, self.gds_format_string(quote_xml(' '.join(self.obis)).encode(ExternalEncoding), input_name='obis'), namespace_, eol_))
        if self.obps is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sobps>%s</%sobps>%s' % (namespace_, self.gds_format_string(quote_xml(' '.join(self.obps)).encode(ExternalEncoding), input_name='obps'), namespace_, eol_))
        if self.dc is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdc>%s</%sdc>%s' % (namespace_, self.gds_format_string(quote_xml(self.dc).encode(ExternalEncoding), input_name='dc'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(mgmtResource, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'mgd':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'mgd')
            self.mgd = ival_
            # validate type mgmtDefinition
            self.validate_mgmtDefinition(self.mgd)
        elif nodeName_ == 'obis':
            obis_ = child_.text
            self.obis = obis_
            # validate type listOfURIs
            self.validate_listOfURIs(self.obis)
        elif nodeName_ == 'obps':
            obps_ = child_.text
            self.obps = obps_
            # validate type listOfURIs
            self.validate_listOfURIs(self.obps)
        elif nodeName_ == 'dc':
            dc_ = child_.text
            dc_ = self.gds_validate_string(dc_, node, 'dc')
            self.dc = dc_
        super(mgmtResource, self).buildChildren(child_, node, nodeName_, True)
# end class mgmtResource


class announcedMgmtResource(announcedResource):
    subclass = None
    superclass = announcedResource
    def __init__(self, rn=None, ty=None, ri=None, pi=None, ct=None, lt=None, lbl=None, acpi=None, et=None, lnk=None, mgd=None, obis=None, obps=None, dc=None):
        self.original_tagname_ = None
        super(announcedMgmtResource, self).__init__(rn, ty, ri, pi, ct, lt, lbl, acpi, et, lnk, )
        self.mgd = mgd
        self.validate_mgmtDefinition(self.mgd)
        self.obis = obis
        self.validate_listOfURIs(self.obis)
        self.obps = obps
        self.validate_listOfURIs(self.obps)
        self.dc = dc
    def factory(*args_, **kwargs_):
        if announcedMgmtResource.subclass:
            return announcedMgmtResource.subclass(*args_, **kwargs_)
        else:
            return announcedMgmtResource(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_mgd(self): return self.mgd
    def set_mgd(self, mgd): self.mgd = mgd
    def get_obis(self): return self.obis
    def set_obis(self, obis): self.obis = obis
    def get_obps(self): return self.obps
    def set_obps(self, obps): self.obps = obps
    def get_dc(self): return self.dc
    def set_dc(self, dc): self.dc = dc
    def validate_mgmtDefinition(self, value):
        # Validate type mgmtDefinition, a restriction on xs:integer.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1001', '1002', '1003', '1004', '1005', '1006', '1007', '1008', '1009', '1010', '1011', '1012', '1013', '1014', '1015', '1016', '1017', '1018', '1019']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on mgmtDefinition' % {"value" : value.encode("utf-8")} )
    def validate_listOfURIs(self, value):
        # Validate type listOfURIs, a restriction on xs:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on listOfURIs' % {"value" : value} )
    def hasContent_(self):
        if (
            self.mgd is not None or
            self.obis is not None or
            self.obps is not None or
            self.dc is not None or
            super(announcedMgmtResource, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='m2m:', name_='announcedMgmtResource', namespacedef_='xmlns:m2m="http://www.onem2m.org/xml/protocols"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='announcedMgmtResource')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='m2m:', name_='announcedMgmtResource', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='m2m:', name_='announcedMgmtResource'):
        super(announcedMgmtResource, self).exportAttributes(outfile, level, already_processed, namespace_, name_='announcedMgmtResource')
    def exportChildren(self, outfile, level, namespace_='m2m:', name_='announcedMgmtResource', fromsubclass_=False, pretty_print=True):
        super(announcedMgmtResource, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.mgd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smgd>%s</%smgd>%s' % (namespace_, self.gds_format_integer(self.mgd, input_name='mgd'), namespace_, eol_))
        if self.obis is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sobis>%s</%sobis>%s' % (namespace_, self.gds_format_string(quote_xml(' '.join(self.obis)).encode(ExternalEncoding), input_name='obis'), namespace_, eol_))
        if self.obps is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sobps>%s</%sobps>%s' % (namespace_, self.gds_format_string(quote_xml(' '.join(self.obps)).encode(ExternalEncoding), input_name='obps'), namespace_, eol_))
        if self.dc is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdc>%s</%sdc>%s' % (namespace_, self.gds_format_string(quote_xml(self.dc).encode(ExternalEncoding), input_name='dc'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(announcedMgmtResource, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'mgd':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'mgd')
            self.mgd = ival_
            # validate type mgmtDefinition
            self.validate_mgmtDefinition(self.mgd)
        elif nodeName_ == 'obis':
            obis_ = child_.text
            self.obis = obis_
            # validate type listOfURIs
            self.validate_listOfURIs(self.obis)
        elif nodeName_ == 'obps':
            obps_ = child_.text
            self.obps = obps_
            # validate type listOfURIs
            self.validate_listOfURIs(self.obps)
        elif nodeName_ == 'dc':
            dc_ = child_.text
            dc_ = self.gds_validate_string(dc_, node, 'dc')
            self.dc = dc_
        super(announcedMgmtResource, self).buildChildren(child_, node, nodeName_, True)
# end class announcedMgmtResource


class cin(announceableSubordinateResource):
    subclass = None
    superclass = announceableSubordinateResource
    def __init__(self, rn=None, ty=None, ri=None, pi=None, ct=None, lt=None, lbl=None, et=None, at=None, aa=None, st=None, cr=None, cnf=None, cs=None, or_=None, con=None):
        self.original_tagname_ = None
        super(cin, self).__init__(rn, ty, ri, pi, ct, lt, lbl, et, at, aa, )
        self.st = st
        self.cr = cr
        self.validate_ID(self.cr)
        self.cnf = cnf
        self.validate_contentInfo(self.cnf)
        self.cs = cs
        self.or_ = or_
        self.con = con
    def factory(*args_, **kwargs_):
        if cin.subclass:
            return cin.subclass(*args_, **kwargs_)
        else:
            return cin(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_st(self): return self.st
    def set_st(self, st): self.st = st
    def get_cr(self): return self.cr
    def set_cr(self, cr): self.cr = cr
    def get_cnf(self): return self.cnf
    def set_cnf(self, cnf): self.cnf = cnf
    def get_cs(self): return self.cs
    def set_cs(self, cs): self.cs = cs
    def get_or(self): return self.or_
    def set_or(self, or_): self.or_ = or_
    def get_con(self): return self.con
    def set_con(self, con): self.con = con
    def validate_ID(self, value):
        # Validate type ID, a restriction on xs:anyURI.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_contentInfo(self, value):
        # Validate type contentInfo, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_contentInfo_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_contentInfo_patterns_, ))
    validate_contentInfo_patterns_ = [['^[\\w/!#$^_.+&\\-]+(:[0-2])?$']]
    def hasContent_(self):
        if (
            self.st is not None or
            self.cr is not None or
            self.cnf is not None or
            self.cs is not None or
            self.or_ is not None or
            self.con is not None or
            super(cin, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='m2m:', name_='cin', namespacedef_='xmlns:m2m="http://www.onem2m.org/xml/protocols"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='cin')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='m2m:', name_='cin', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='m2m:', name_='cin'):
        super(cin, self).exportAttributes(outfile, level, already_processed, namespace_, name_='cin')
    def exportChildren(self, outfile, level, namespace_='m2m:', name_='cin', fromsubclass_=False, pretty_print=True):
        super(cin, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.st is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sst>%s</%sst>%s' % (namespace_, self.gds_format_integer(self.st, input_name='st'), namespace_, eol_))
        if self.cr is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scr>%s</%scr>%s' % (namespace_, self.gds_format_string(quote_xml(self.cr).encode(ExternalEncoding), input_name='cr'), namespace_, eol_))
        if self.cnf is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scnf>%s</%scnf>%s' % (namespace_, self.gds_format_string(quote_xml(self.cnf).encode(ExternalEncoding), input_name='cnf'), namespace_, eol_))
        if self.cs is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scs>%s</%scs>%s' % (namespace_, self.gds_format_integer(self.cs, input_name='cs'), namespace_, eol_))
        if self.or_ is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sor>%s</%sor>%s' % (namespace_, self.gds_format_string(quote_xml(self.or_).encode(ExternalEncoding), input_name='or'), namespace_, eol_))
        if self.con is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scon>%s</%scon>%s' % (namespace_, self.gds_format_string(quote_xml(self.con).encode(ExternalEncoding), input_name='con'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(cin, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'st':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'st')
            self.st = ival_
        elif nodeName_ == 'cr':
            cr_ = child_.text
            cr_ = self.gds_validate_string(cr_, node, 'cr')
            self.cr = cr_
            # validate type ID
            self.validate_ID(self.cr)
        elif nodeName_ == 'cnf':
            cnf_ = child_.text
            cnf_ = self.gds_validate_string(cnf_, node, 'cnf')
            self.cnf = cnf_
            # validate type contentInfo
            self.validate_contentInfo(self.cnf)
        elif nodeName_ == 'cs':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'cs')
            self.cs = ival_
        elif nodeName_ == 'or':
            or_ = child_.text
            or_ = self.gds_validate_string(or_, node, 'or')
            self.or_ = or_
        elif nodeName_ == 'con':
            con_ = child_.text
            con_ = self.gds_validate_string(con_, node, 'con')
            self.con = con_
        super(cin, self).buildChildren(child_, node, nodeName_, True)
# end class cin


class cinA(announcedSubordinateResource):
    subclass = None
    superclass = announcedSubordinateResource
    def __init__(self, rn=None, ty=None, ri=None, pi=None, ct=None, lt=None, lbl=None, et=None, lnk=None, st=None, cnf=None, cs=None, or_=None, con=None):
        self.original_tagname_ = None
        super(cinA, self).__init__(rn, ty, ri, pi, ct, lt, lbl, et, lnk, )
        self.st = st
        self.cnf = cnf
        self.validate_contentInfo(self.cnf)
        self.cs = cs
        self.or_ = or_
        self.con = con
    def factory(*args_, **kwargs_):
        if cinA.subclass:
            return cinA.subclass(*args_, **kwargs_)
        else:
            return cinA(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_st(self): return self.st
    def set_st(self, st): self.st = st
    def get_cnf(self): return self.cnf
    def set_cnf(self, cnf): self.cnf = cnf
    def get_cs(self): return self.cs
    def set_cs(self, cs): self.cs = cs
    def get_or(self): return self.or_
    def set_or(self, or_): self.or_ = or_
    def get_con(self): return self.con
    def set_con(self, con): self.con = con
    def validate_contentInfo(self, value):
        # Validate type contentInfo, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_contentInfo_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_contentInfo_patterns_, ))
    validate_contentInfo_patterns_ = [['^[\\w/!#$^_.+&\\-]+(:[0-2])?$']]
    def hasContent_(self):
        if (
            self.st is not None or
            self.cnf is not None or
            self.cs is not None or
            self.or_ is not None or
            self.con is not None or
            super(cinA, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='m2m:', name_='cinA', namespacedef_='xmlns:m2m="http://www.onem2m.org/xml/protocols"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='cinA')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='m2m:', name_='cinA', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='m2m:', name_='cinA'):
        super(cinA, self).exportAttributes(outfile, level, already_processed, namespace_, name_='cinA')
    def exportChildren(self, outfile, level, namespace_='m2m:', name_='cinA', fromsubclass_=False, pretty_print=True):
        super(cinA, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.st is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sst>%s</%sst>%s' % (namespace_, self.gds_format_integer(self.st, input_name='st'), namespace_, eol_))
        if self.cnf is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scnf>%s</%scnf>%s' % (namespace_, self.gds_format_string(quote_xml(self.cnf).encode(ExternalEncoding), input_name='cnf'), namespace_, eol_))
        if self.cs is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scs>%s</%scs>%s' % (namespace_, self.gds_format_integer(self.cs, input_name='cs'), namespace_, eol_))
        if self.or_ is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sor>%s</%sor>%s' % (namespace_, self.gds_format_string(quote_xml(self.or_).encode(ExternalEncoding), input_name='or'), namespace_, eol_))
        if self.con is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scon>%s</%scon>%s' % (namespace_, self.gds_format_string(quote_xml(self.con).encode(ExternalEncoding), input_name='con'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(cinA, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'st':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'st')
            self.st = ival_
        elif nodeName_ == 'cnf':
            cnf_ = child_.text
            cnf_ = self.gds_validate_string(cnf_, node, 'cnf')
            self.cnf = cnf_
            # validate type contentInfo
            self.validate_contentInfo(self.cnf)
        elif nodeName_ == 'cs':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'cs')
            self.cs = ival_
        elif nodeName_ == 'or':
            or_ = child_.text
            or_ = self.gds_validate_string(or_, node, 'or')
            self.or_ = or_
        elif nodeName_ == 'con':
            con_ = child_.text
            con_ = self.gds_validate_string(con_, node, 'con')
            self.con = con_
        super(cinA, self).buildChildren(child_, node, nodeName_, True)
# end class cinA


class sub(regularResource):
    subclass = None
    superclass = regularResource
    def __init__(self, rn=None, ty=None, ri=None, pi=None, ct=None, lt=None, lbl=None, acpi=None, et=None, enc=None, exc=None, nu=None, gpi=None, nfu=None, bn=None, rl=None, psn=None, pn=None, nsp=None, ln=None, nct=None, nec=None, cr=None, su=None, ch=None, sch=None):
        self.original_tagname_ = None
        super(sub, self).__init__(rn, ty, ri, pi, ct, lt, lbl, acpi, et, )
        self.enc = enc
        self.exc = exc
        self.nu = nu
        self.validate_listOfURIs(self.nu)
        self.gpi = gpi
        self.nfu = nfu
        self.bn = bn
        self.rl = rl
        self.psn = psn
        self.pn = pn
        self.validate_pendingNotification(self.pn)
        self.nsp = nsp
        self.ln = ln
        self.nct = nct
        self.validate_notificationContentType(self.nct)
        self.nec = nec
        self.validate_eventCat(self.nec)
        self.cr = cr
        self.validate_ID(self.cr)
        self.su = su
        self.ch = ch
        self.sch = sch
    def factory(*args_, **kwargs_):
        if sub.subclass:
            return sub.subclass(*args_, **kwargs_)
        else:
            return sub(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_enc(self): return self.enc
    def set_enc(self, enc): self.enc = enc
    def get_exc(self): return self.exc
    def set_exc(self, exc): self.exc = exc
    def get_nu(self): return self.nu
    def set_nu(self, nu): self.nu = nu
    def get_gpi(self): return self.gpi
    def set_gpi(self, gpi): self.gpi = gpi
    def get_nfu(self): return self.nfu
    def set_nfu(self, nfu): self.nfu = nfu
    def get_bn(self): return self.bn
    def set_bn(self, bn): self.bn = bn
    def get_rl(self): return self.rl
    def set_rl(self, rl): self.rl = rl
    def get_psn(self): return self.psn
    def set_psn(self, psn): self.psn = psn
    def get_pn(self): return self.pn
    def set_pn(self, pn): self.pn = pn
    def get_nsp(self): return self.nsp
    def set_nsp(self, nsp): self.nsp = nsp
    def get_ln(self): return self.ln
    def set_ln(self, ln): self.ln = ln
    def get_nct(self): return self.nct
    def set_nct(self, nct): self.nct = nct
    def get_nec(self): return self.nec
    def set_nec(self, nec): self.nec = nec
    def get_cr(self): return self.cr
    def set_cr(self, cr): self.cr = cr
    def get_su(self): return self.su
    def set_su(self, su): self.su = su
    def get_ch(self): return self.ch
    def set_ch(self, ch): self.ch = ch
    def get_sch(self): return self.sch
    def set_sch(self, sch): self.sch = sch
    def validate_listOfURIs(self, value):
        # Validate type listOfURIs, a restriction on xs:anyURI.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on listOfURIs' % {"value" : value} )
    def validate_pendingNotification(self, value):
        # Validate type pendingNotification, a restriction on xs:integer.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['1', '2']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on pendingNotification' % {"value" : value.encode("utf-8")} )
    def validate_notificationContentType(self, value):
        # Validate type notificationContentType, a restriction on xs:integer.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['1', '2', '3']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on notificationContentType' % {"value" : value.encode("utf-8")} )
    def validate_eventCat(self, value):
        # Validate type eventCat, a restriction on xs:integer.
        pass
    def validate_ID(self, value):
        # Validate type ID, a restriction on xs:anyURI.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.enc is not None or
            self.exc is not None or
            self.nu is not None or
            self.gpi is not None or
            self.nfu is not None or
            self.bn is not None or
            self.rl is not None or
            self.psn is not None or
            self.pn is not None or
            self.nsp is not None or
            self.ln is not None or
            self.nct is not None or
            self.nec is not None or
            self.cr is not None or
            self.su is not None or
            self.ch is not None or
            self.sch is not None or
            super(sub, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='m2m:', name_='sub', namespacedef_='xmlns:m2m="http://www.onem2m.org/xml/protocols"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='sub')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='m2m:', name_='sub', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='m2m:', name_='sub'):
        super(sub, self).exportAttributes(outfile, level, already_processed, namespace_, name_='sub')
    def exportChildren(self, outfile, level, namespace_='m2m:', name_='sub', fromsubclass_=False, pretty_print=True):
        super(sub, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.enc is not None:
            self.enc.export(outfile, level, namespace_, name_='enc', pretty_print=pretty_print)
        if self.exc is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sexc>%s</%sexc>%s' % (namespace_, self.gds_format_integer(self.exc, input_name='exc'), namespace_, eol_))
        if self.nu is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snu>%s</%snu>%s' % (namespace_, self.gds_format_string(quote_xml(' '.join(self.nu)).encode(ExternalEncoding), input_name='nu'), namespace_, eol_))
        if self.gpi is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sgpi>%s</%sgpi>%s' % (namespace_, self.gds_format_string(quote_xml(self.gpi).encode(ExternalEncoding), input_name='gpi'), namespace_, eol_))
        if self.nfu is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snfu>%s</%snfu>%s' % (namespace_, self.gds_format_string(quote_xml(self.nfu).encode(ExternalEncoding), input_name='nfu'), namespace_, eol_))
        if self.bn is not None:
            self.bn.export(outfile, level, namespace_, name_='bn', pretty_print=pretty_print)
        if self.rl is not None:
            self.rl.export(outfile, level, namespace_, name_='rl', pretty_print=pretty_print)
        if self.psn is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spsn>%s</%spsn>%s' % (namespace_, self.gds_format_integer(self.psn, input_name='psn'), namespace_, eol_))
        if self.pn is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spn>%s</%spn>%s' % (namespace_, self.gds_format_integer(self.pn, input_name='pn'), namespace_, eol_))
        if self.nsp is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snsp>%s</%snsp>%s' % (namespace_, self.gds_format_integer(self.nsp, input_name='nsp'), namespace_, eol_))
        if self.ln is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sln>%s</%sln>%s' % (namespace_, self.gds_format_boolean(self.ln, input_name='ln'), namespace_, eol_))
        if self.nct is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snct>%s</%snct>%s' % (namespace_, self.gds_format_integer(self.nct, input_name='nct'), namespace_, eol_))
        if self.nec is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snec>%s</%snec>%s' % (namespace_, self.gds_format_integer(self.nec, input_name='nec'), namespace_, eol_))
        if self.cr is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scr>%s</%scr>%s' % (namespace_, self.gds_format_string(quote_xml(self.cr).encode(ExternalEncoding), input_name='cr'), namespace_, eol_))
        if self.su is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssu>%s</%ssu>%s' % (namespace_, self.gds_format_string(quote_xml(self.su).encode(ExternalEncoding), input_name='su'), namespace_, eol_))
        if self.ch is not None:
            self.ch.export(outfile, level, namespace_, name_='ch', pretty_print=pretty_print)
        if self.sch is not None:
            self.sch.export(outfile, level, namespace_='m2m:', name_='sch', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(sub, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'enc':
            obj_ = eventNotificationCriteria.factory()
            obj_.build(child_)
            self.enc = obj_
            obj_.original_tagname_ = 'enc'
        elif nodeName_ == 'exc':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'exc')
            self.exc = ival_
        elif nodeName_ == 'nu':
            nu_ = child_.text
            self.nu = nu_
            # validate type listOfURIs
            self.validate_listOfURIs(self.nu)
        elif nodeName_ == 'gpi':
            gpi_ = child_.text
            gpi_ = self.gds_validate_string(gpi_, node, 'gpi')
            self.gpi = gpi_
        elif nodeName_ == 'nfu':
            nfu_ = child_.text
            nfu_ = self.gds_validate_string(nfu_, node, 'nfu')
            self.nfu = nfu_
        elif nodeName_ == 'bn':
            obj_ = batchNotify.factory()
            obj_.build(child_)
            self.bn = obj_
            obj_.original_tagname_ = 'bn'
        elif nodeName_ == 'rl':
            obj_ = rateLimit.factory()
            obj_.build(child_)
            self.rl = obj_
            obj_.original_tagname_ = 'rl'
        elif nodeName_ == 'psn':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'psn')
            self.psn = ival_
        elif nodeName_ == 'pn':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'pn')
            self.pn = ival_
            # validate type pendingNotification
            self.validate_pendingNotification(self.pn)
        elif nodeName_ == 'nsp':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'nsp')
            self.nsp = ival_
        elif nodeName_ == 'ln':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'ln')
            self.ln = ival_
        elif nodeName_ == 'nct':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'nct')
            self.nct = ival_
            # validate type notificationContentType
            self.validate_notificationContentType(self.nct)
        elif nodeName_ == 'nec':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'nec')
            self.nec = ival_
            # validate type eventCat
            self.validate_eventCat(self.nec)
        elif nodeName_ == 'cr':
            cr_ = child_.text
            cr_ = self.gds_validate_string(cr_, node, 'cr')
            self.cr = cr_
            # validate type ID
            self.validate_ID(self.cr)
        elif nodeName_ == 'su':
            su_ = child_.text
            su_ = self.gds_validate_string(su_, node, 'su')
            self.su = su_
        elif nodeName_ == 'ch':
            obj_ = childResourceRef.factory()
            obj_.build(child_)
            self.ch = obj_
            obj_.original_tagname_ = 'ch'
        elif nodeName_ == 'sch':
            obj_ = sch.factory()
            obj_.build(child_)
            self.sch = obj_
            obj_.original_tagname_ = 'sch'
        super(sub, self).buildChildren(child_, node, nodeName_, True)
# end class sub


class eventNotificationCriteria(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, crb=None, cra=None, ms=None, us=None, sts=None, stb=None, exb=None, exa=None, sza=None, szb=None, om=None, atr=None, net=None):
        self.original_tagname_ = None
        self.crb = crb
        self.validate_timestamp(self.crb)
        self.cra = cra
        self.validate_timestamp(self.cra)
        self.ms = ms
        self.validate_timestamp(self.ms)
        self.us = us
        self.validate_timestamp(self.us)
        self.sts = sts
        self.stb = stb
        self.exb = exb
        self.validate_timestamp(self.exb)
        self.exa = exa
        self.validate_timestamp(self.exa)
        self.sza = sza
        self.szb = szb
        if om is None:
            self.om = []
        else:
            self.om = om
        if atr is None:
            self.atr = []
        else:
            self.atr = atr
        if net is None:
            self.net = []
        else:
            self.net = net
    def factory(*args_, **kwargs_):
        if eventNotificationCriteria.subclass:
            return eventNotificationCriteria.subclass(*args_, **kwargs_)
        else:
            return eventNotificationCriteria(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_crb(self): return self.crb
    def set_crb(self, crb): self.crb = crb
    def get_cra(self): return self.cra
    def set_cra(self, cra): self.cra = cra
    def get_ms(self): return self.ms
    def set_ms(self, ms): self.ms = ms
    def get_us(self): return self.us
    def set_us(self, us): self.us = us
    def get_sts(self): return self.sts
    def set_sts(self, sts): self.sts = sts
    def get_stb(self): return self.stb
    def set_stb(self, stb): self.stb = stb
    def get_exb(self): return self.exb
    def set_exb(self, exb): self.exb = exb
    def get_exa(self): return self.exa
    def set_exa(self, exa): self.exa = exa
    def get_sza(self): return self.sza
    def set_sza(self, sza): self.sza = sza
    def get_szb(self): return self.szb
    def set_szb(self, szb): self.szb = szb
    def get_om(self): return self.om
    def set_om(self, om): self.om = om
    def add_om(self, value): self.om.append(value)
    def insert_om_at(self, index, value): self.om.insert(index, value)
    def replace_om_at(self, index, value): self.om[index] = value
    def get_atr(self): return self.atr
    def set_atr(self, atr): self.atr = atr
    def add_atr(self, value): self.atr.append(value)
    def insert_atr_at(self, index, value): self.atr.insert(index, value)
    def replace_atr_at(self, index, value): self.atr[index] = value
    def get_net(self): return self.net
    def set_net(self, net): self.net = net
    def add_net(self, value): self.net.append(value)
    def insert_net_at(self, index, value): self.net.insert(index, value)
    def replace_net_at(self, index, value): self.net[index] = value
    def validate_timestamp(self, value):
        # Validate type timestamp, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_timestamp_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_timestamp_patterns_, ))
    validate_timestamp_patterns_ = [['^\\d{4}(0[1-9]|1[0-2])(0[1-9]|[1-2]\\d|30|31)T([01]\\d|2[0-3])[0-5]\\d[0-5]\\d(,\\d{1,6})?$']]
    def validate_operation(self, value):
        # Validate type operation, a restriction on xs:integer.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['1', '2', '3', '4', '5']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on operation' % {"value" : value.encode("utf-8")} )
    def validate_notificationEventType(self, value):
        # Validate type notificationEventType, a restriction on xs:integer.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['1', '2', '3', '4']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on notificationEventType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.crb is not None or
            self.cra is not None or
            self.ms is not None or
            self.us is not None or
            self.sts is not None or
            self.stb is not None or
            self.exb is not None or
            self.exa is not None or
            self.sza is not None or
            self.szb is not None or
            self.om or
            self.atr or
            self.net
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='m2m:', name_='eventNotificationCriteria', namespacedef_='xmlns:m2m="http://www.onem2m.org/xml/protocols"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='eventNotificationCriteria')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='m2m:', name_='eventNotificationCriteria', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='m2m:', name_='eventNotificationCriteria'):
        pass
    def exportChildren(self, outfile, level, namespace_='m2m:', name_='eventNotificationCriteria', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.crb is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scrb>%s</%scrb>%s' % (namespace_, self.gds_format_string(quote_xml(self.crb).encode(ExternalEncoding), input_name='crb'), namespace_, eol_))
        if self.cra is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scra>%s</%scra>%s' % (namespace_, self.gds_format_string(quote_xml(self.cra).encode(ExternalEncoding), input_name='cra'), namespace_, eol_))
        if self.ms is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sms>%s</%sms>%s' % (namespace_, self.gds_format_string(quote_xml(self.ms).encode(ExternalEncoding), input_name='ms'), namespace_, eol_))
        if self.us is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sus>%s</%sus>%s' % (namespace_, self.gds_format_string(quote_xml(self.us).encode(ExternalEncoding), input_name='us'), namespace_, eol_))
        if self.sts is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssts>%s</%ssts>%s' % (namespace_, self.gds_format_integer(self.sts, input_name='sts'), namespace_, eol_))
        if self.stb is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstb>%s</%sstb>%s' % (namespace_, self.gds_format_integer(self.stb, input_name='stb'), namespace_, eol_))
        if self.exb is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sexb>%s</%sexb>%s' % (namespace_, self.gds_format_string(quote_xml(self.exb).encode(ExternalEncoding), input_name='exb'), namespace_, eol_))
        if self.exa is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sexa>%s</%sexa>%s' % (namespace_, self.gds_format_string(quote_xml(self.exa).encode(ExternalEncoding), input_name='exa'), namespace_, eol_))
        if self.sza is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssza>%s</%ssza>%s' % (namespace_, self.gds_format_integer(self.sza, input_name='sza'), namespace_, eol_))
        if self.szb is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sszb>%s</%sszb>%s' % (namespace_, self.gds_format_integer(self.szb, input_name='szb'), namespace_, eol_))
        for om_ in self.om:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%som>%s</%som>%s' % (namespace_, self.gds_format_integer(om_, input_name='om'), namespace_, eol_))
        for atr_ in self.atr:
            atr_.export(outfile, level, namespace_, name_='atr', pretty_print=pretty_print)
        for net_ in self.net:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snet>%s</%snet>%s' % (namespace_, self.gds_format_integer(net_, input_name='net'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'crb':
            crb_ = child_.text
            crb_ = self.gds_validate_string(crb_, node, 'crb')
            self.crb = crb_
            # validate type timestamp
            self.validate_timestamp(self.crb)
        elif nodeName_ == 'cra':
            cra_ = child_.text
            cra_ = self.gds_validate_string(cra_, node, 'cra')
            self.cra = cra_
            # validate type timestamp
            self.validate_timestamp(self.cra)
        elif nodeName_ == 'ms':
            ms_ = child_.text
            ms_ = self.gds_validate_string(ms_, node, 'ms')
            self.ms = ms_
            # validate type timestamp
            self.validate_timestamp(self.ms)
        elif nodeName_ == 'us':
            us_ = child_.text
            us_ = self.gds_validate_string(us_, node, 'us')
            self.us = us_
            # validate type timestamp
            self.validate_timestamp(self.us)
        elif nodeName_ == 'sts':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'sts')
            self.sts = ival_
        elif nodeName_ == 'stb':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'stb')
            self.stb = ival_
        elif nodeName_ == 'exb':
            exb_ = child_.text
            exb_ = self.gds_validate_string(exb_, node, 'exb')
            self.exb = exb_
            # validate type timestamp
            self.validate_timestamp(self.exb)
        elif nodeName_ == 'exa':
            exa_ = child_.text
            exa_ = self.gds_validate_string(exa_, node, 'exa')
            self.exa = exa_
            # validate type timestamp
            self.validate_timestamp(self.exa)
        elif nodeName_ == 'sza':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'sza')
            self.sza = ival_
        elif nodeName_ == 'szb':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'szb')
            self.szb = ival_
        elif nodeName_ == 'om':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'om')
            self.om.append(ival_)
            # validate type operation
            self.validate_operation(self.om[-1])
        elif nodeName_ == 'atr':
            obj_ = attribute.factory()
            obj_.build(child_)
            self.atr.append(obj_)
            obj_.original_tagname_ = 'atr'
        elif nodeName_ == 'net':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'net')
            self.net.append(ival_)
            # validate type notificationEventType
            self.validate_notificationEventType(self.net[-1])
# end class eventNotificationCriteria


class batchNotify(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, num=None, dur=None):
        self.original_tagname_ = None
        self.num = num
        self.dur = dur
    def factory(*args_, **kwargs_):
        if batchNotify.subclass:
            return batchNotify.subclass(*args_, **kwargs_)
        else:
            return batchNotify(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_num(self): return self.num
    def set_num(self, num): self.num = num
    def get_dur(self): return self.dur
    def set_dur(self, dur): self.dur = dur
    def hasContent_(self):
        if (
            self.num is not None or
            self.dur is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='m2m:', name_='batchNotify', namespacedef_='xmlns:m2m="http://www.onem2m.org/xml/protocols"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='batchNotify')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='m2m:', name_='batchNotify', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='m2m:', name_='batchNotify'):
        pass
    def exportChildren(self, outfile, level, namespace_='m2m:', name_='batchNotify', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.num is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snum>%s</%snum>%s' % (namespace_, self.gds_format_integer(self.num, input_name='num'), namespace_, eol_))
        if self.dur is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdur>%s</%sdur>%s' % (namespace_, self.gds_format_string(quote_xml(self.dur).encode(ExternalEncoding), input_name='dur'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'num':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'num')
            self.num = ival_
        elif nodeName_ == 'dur':
            dur_ = child_.text
            dur_ = self.gds_validate_string(dur_, node, 'dur')
            self.dur = dur_
# end class batchNotify


class rateLimit(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, mnn=None, tww=None):
        self.original_tagname_ = None
        self.mnn = mnn
        self.tww = tww
    def factory(*args_, **kwargs_):
        if rateLimit.subclass:
            return rateLimit.subclass(*args_, **kwargs_)
        else:
            return rateLimit(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_mnn(self): return self.mnn
    def set_mnn(self, mnn): self.mnn = mnn
    def get_tww(self): return self.tww
    def set_tww(self, tww): self.tww = tww
    def hasContent_(self):
        if (
            self.mnn is not None or
            self.tww is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='m2m:', name_='rateLimit', namespacedef_='xmlns:m2m="http://www.onem2m.org/xml/protocols"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='rateLimit')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='m2m:', name_='rateLimit', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='m2m:', name_='rateLimit'):
        pass
    def exportChildren(self, outfile, level, namespace_='m2m:', name_='rateLimit', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.mnn is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smnn>%s</%smnn>%s' % (namespace_, self.gds_format_integer(self.mnn, input_name='mnn'), namespace_, eol_))
        if self.tww is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stww>%s</%stww>%s' % (namespace_, self.gds_format_string(quote_xml(self.tww).encode(ExternalEncoding), input_name='tww'), namespace_, eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'mnn':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'mnn')
            self.mnn = ival_
        elif nodeName_ == 'tww':
            tww_ = child_.text
            tww_ = self.gds_validate_string(tww_, node, 'tww')
            self.tww = tww_
# end class rateLimit


class sch(announceableSubordinateResource):
    subclass = None
    superclass = announceableSubordinateResource
    def __init__(self, rn=None, ty=None, ri=None, pi=None, ct=None, lt=None, lbl=None, et=None, at=None, aa=None, se=None, ch=None, sub=None):
        self.original_tagname_ = None
        super(sch, self).__init__(rn, ty, ri, pi, ct, lt, lbl, et, at, aa, )
        self.se = se
        if ch is None:
            self.ch = []
        else:
            self.ch = ch
        if sub is None:
            self.sub = []
        else:
            self.sub = sub
    def factory(*args_, **kwargs_):
        if sch.subclass:
            return sch.subclass(*args_, **kwargs_)
        else:
            return sch(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_se(self): return self.se
    def set_se(self, se): self.se = se
    def get_ch(self): return self.ch
    def set_ch(self, ch): self.ch = ch
    def add_ch(self, value): self.ch.append(value)
    def insert_ch_at(self, index, value): self.ch.insert(index, value)
    def replace_ch_at(self, index, value): self.ch[index] = value
    def get_sub(self): return self.sub
    def set_sub(self, sub): self.sub = sub
    def add_sub(self, value): self.sub.append(value)
    def insert_sub_at(self, index, value): self.sub.insert(index, value)
    def replace_sub_at(self, index, value): self.sub[index] = value
    def hasContent_(self):
        if (
            self.se is not None or
            self.ch or
            self.sub or
            super(sch, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='m2m:', name_='sch', namespacedef_='xmlns:m2m="http://www.onem2m.org/xml/protocols"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='sch')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='m2m:', name_='sch', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='m2m:', name_='sch'):
        super(sch, self).exportAttributes(outfile, level, already_processed, namespace_, name_='sch')
    def exportChildren(self, outfile, level, namespace_='m2m:', name_='sch', fromsubclass_=False, pretty_print=True):
        super(sch, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.se is not None:
            self.se.export(outfile, level, namespace_, name_='se', pretty_print=pretty_print)
        for ch_ in self.ch:
            ch_.export(outfile, level, namespace_, name_='ch', pretty_print=pretty_print)
        for sub_ in self.sub:
            sub_.export(outfile, level, namespace_='m2m:', name_='sub', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(sch, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'se':
            obj_ = scheduleEntries.factory()
            obj_.build(child_)
            self.se = obj_
            obj_.original_tagname_ = 'se'
        elif nodeName_ == 'ch':
            obj_ = childResourceRef.factory()
            obj_.build(child_)
            self.ch.append(obj_)
            obj_.original_tagname_ = 'ch'
        elif nodeName_ == 'sub':
            obj_ = sub.factory()
            obj_.build(child_)
            self.sub.append(obj_)
            obj_.original_tagname_ = 'sub'
        super(sch, self).buildChildren(child_, node, nodeName_, True)
# end class sch


class schA(announcedSubordinateResource):
    subclass = None
    superclass = announcedSubordinateResource
    def __init__(self, rn=None, ty=None, ri=None, pi=None, ct=None, lt=None, lbl=None, et=None, lnk=None, se=None):
        self.original_tagname_ = None
        super(schA, self).__init__(rn, ty, ri, pi, ct, lt, lbl, et, lnk, )
        self.se = se
    def factory(*args_, **kwargs_):
        if schA.subclass:
            return schA.subclass(*args_, **kwargs_)
        else:
            return schA(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_se(self): return self.se
    def set_se(self, se): self.se = se
    def hasContent_(self):
        if (
            self.se is not None or
            super(schA, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='m2m:', name_='schA', namespacedef_='xmlns:m2m="http://www.onem2m.org/xml/protocols"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='schA')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='m2m:', name_='schA', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='m2m:', name_='schA'):
        super(schA, self).exportAttributes(outfile, level, already_processed, namespace_, name_='schA')
    def exportChildren(self, outfile, level, namespace_='m2m:', name_='schA', fromsubclass_=False, pretty_print=True):
        super(schA, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.se is not None:
            self.se.export(outfile, level, namespace_, name_='se', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(schA, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'se':
            obj_ = scheduleEntries.factory()
            obj_.build(child_)
            self.se = obj_
            obj_.original_tagname_ = 'se'
        super(schA, self).buildChildren(child_, node, nodeName_, True)
# end class schA


class reqType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, op=None, to=None, fr=None, rqi=None, pc=None, mi=None):
        self.original_tagname_ = None
        self.op = op
        self.validate_operation(self.op)
        self.to = to
        self.fr = fr
        self.validate_ID(self.fr)
        self.rqi = rqi
        self.validate_requestID(self.rqi)
        self.pc = pc
        self.mi = mi
    def factory(*args_, **kwargs_):
        if reqType.subclass:
            return reqType.subclass(*args_, **kwargs_)
        else:
            return reqType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_op(self): return self.op
    def set_op(self, op): self.op = op
    def get_to(self): return self.to
    def set_to(self, to): self.to = to
    def get_fr(self): return self.fr
    def set_fr(self, fr): self.fr = fr
    def get_rqi(self): return self.rqi
    def set_rqi(self, rqi): self.rqi = rqi
    def get_pc(self): return self.pc
    def set_pc(self, pc): self.pc = pc
    def get_mi(self): return self.mi
    def set_mi(self, mi): self.mi = mi
    def validate_operation(self, value):
        # Validate type operation, a restriction on xs:integer.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['1', '2', '3', '4', '5']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on operation' % {"value" : value.encode("utf-8")} )
    def validate_ID(self, value):
        # Validate type ID, a restriction on xs:anyURI.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_requestID(self, value):
        # Validate type requestID, a restriction on xs:token.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.op is not None or
            self.to is not None or
            self.fr is not None or
            self.rqi is not None or
            self.pc is not None or
            self.mi is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='m2m:', name_='reqType', namespacedef_='xmlns:m2m="http://www.onem2m.org/xml/protocols"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='reqType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='m2m:', name_='reqType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='m2m:', name_='reqType'):
        pass
    def exportChildren(self, outfile, level, namespace_='m2m:', name_='reqType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.op is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sop>%s</%sop>%s' % (namespace_, self.gds_format_integer(self.op, input_name='op'), namespace_, eol_))
        if self.to is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sto>%s</%sto>%s' % (namespace_, self.gds_format_string(quote_xml(self.to).encode(ExternalEncoding), input_name='to'), namespace_, eol_))
        if self.fr is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfr>%s</%sfr>%s' % (namespace_, self.gds_format_string(quote_xml(self.fr).encode(ExternalEncoding), input_name='fr'), namespace_, eol_))
        if self.rqi is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srqi>%s</%srqi>%s' % (namespace_, self.gds_format_string(quote_xml(self.rqi).encode(ExternalEncoding), input_name='rqi'), namespace_, eol_))
        if self.pc is not None:
            self.pc.export(outfile, level, namespace_, name_='pc', pretty_print=pretty_print)
        if self.mi is not None:
            self.mi.export(outfile, level, namespace_, name_='mi', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'op':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'op')
            self.op = ival_
            # validate type operation
            self.validate_operation(self.op)
        elif nodeName_ == 'to':
            to_ = child_.text
            to_ = self.gds_validate_string(to_, node, 'to')
            self.to = to_
        elif nodeName_ == 'fr':
            fr_ = child_.text
            fr_ = self.gds_validate_string(fr_, node, 'fr')
            self.fr = fr_
            # validate type ID
            self.validate_ID(self.fr)
        elif nodeName_ == 'rqi':
            rqi_ = child_.text
            rqi_ = re_.sub(String_cleanup_pat_, " ", rqi_).strip()
            rqi_ = self.gds_validate_string(rqi_, node, 'rqi')
            self.rqi = rqi_
            # validate type requestID
            self.validate_requestID(self.rqi)
        elif nodeName_ == 'pc':
            obj_ = primitiveContent.factory()
            obj_.build(child_)
            self.pc = obj_
            obj_.original_tagname_ = 'pc'
        elif nodeName_ == 'mi':
            obj_ = metaInformation.factory()
            obj_.build(child_)
            self.mi = obj_
            obj_.original_tagname_ = 'mi'
# end class reqType


class cntA(announcedResource):
    subclass = None
    superclass = announcedResource
    def __init__(self, rn=None, ty=None, ri=None, pi=None, ct=None, lt=None, lbl=None, acpi=None, et=None, lnk=None, st=None, mni=None, mbs=None, mia=None, cni=None, cbs=None, li=None, or_=None, ch=None, cin=None, cinA=None, cnt=None, cntA_member=None, sub=None):
        self.original_tagname_ = None
        super(cntA, self).__init__(rn, ty, ri, pi, ct, lt, lbl, acpi, et, lnk, )
        self.st = st
        self.mni = mni
        self.mbs = mbs
        self.mia = mia
        self.cni = cni
        self.cbs = cbs
        self.li = li
        self.or_ = or_
        if ch is None:
            self.ch = []
        else:
            self.ch = ch
        if cin is None:
            self.cin = []
        else:
            self.cin = cin
        if cinA is None:
            self.cinA = []
        else:
            self.cinA = cinA
        if cnt is None:
            self.cnt = []
        else:
            self.cnt = cnt
        if cntA_member is None:
            self.cntA = []
        else:
            self.cntA = cntA_member
        if sub is None:
            self.sub = []
        else:
            self.sub = sub
    def factory(*args_, **kwargs_):
        if cntA.subclass:
            return cntA.subclass(*args_, **kwargs_)
        else:
            return cntA(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_st(self): return self.st
    def set_st(self, st): self.st = st
    def get_mni(self): return self.mni
    def set_mni(self, mni): self.mni = mni
    def get_mbs(self): return self.mbs
    def set_mbs(self, mbs): self.mbs = mbs
    def get_mia(self): return self.mia
    def set_mia(self, mia): self.mia = mia
    def get_cni(self): return self.cni
    def set_cni(self, cni): self.cni = cni
    def get_cbs(self): return self.cbs
    def set_cbs(self, cbs): self.cbs = cbs
    def get_li(self): return self.li
    def set_li(self, li): self.li = li
    def get_or(self): return self.or_
    def set_or(self, or_): self.or_ = or_
    def get_ch(self): return self.ch
    def set_ch(self, ch): self.ch = ch
    def add_ch(self, value): self.ch.append(value)
    def insert_ch_at(self, index, value): self.ch.insert(index, value)
    def replace_ch_at(self, index, value): self.ch[index] = value
    def get_cin(self): return self.cin
    def set_cin(self, cin): self.cin = cin
    def add_cin(self, value): self.cin.append(value)
    def insert_cin_at(self, index, value): self.cin.insert(index, value)
    def replace_cin_at(self, index, value): self.cin[index] = value
    def get_cinA(self): return self.cinA
    def set_cinA(self, cinA): self.cinA = cinA
    def add_cinA(self, value): self.cinA.append(value)
    def insert_cinA_at(self, index, value): self.cinA.insert(index, value)
    def replace_cinA_at(self, index, value): self.cinA[index] = value
    def get_cnt(self): return self.cnt
    def set_cnt(self, cnt): self.cnt = cnt
    def add_cnt(self, value): self.cnt.append(value)
    def insert_cnt_at(self, index, value): self.cnt.insert(index, value)
    def replace_cnt_at(self, index, value): self.cnt[index] = value
    def get_cntA(self): return self.cntA
    def set_cntA(self, cntA): self.cntA = cntA
    def add_cntA(self, value): self.cntA.append(value)
    def insert_cntA_at(self, index, value): self.cntA.insert(index, value)
    def replace_cntA_at(self, index, value): self.cntA[index] = value
    def get_sub(self): return self.sub
    def set_sub(self, sub): self.sub = sub
    def add_sub(self, value): self.sub.append(value)
    def insert_sub_at(self, index, value): self.sub.insert(index, value)
    def replace_sub_at(self, index, value): self.sub[index] = value
    def hasContent_(self):
        if (
            self.st is not None or
            self.mni is not None or
            self.mbs is not None or
            self.mia is not None or
            self.cni is not None or
            self.cbs is not None or
            self.li is not None or
            self.or_ is not None or
            self.ch or
            self.cin or
            self.cinA or
            self.cnt or
            self.cntA or
            self.sub or
            super(cntA, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='m2m:', name_='cntA', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='cntA')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='m2m:', name_='cntA', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='m2m:', name_='cntA'):
        super(cntA, self).exportAttributes(outfile, level, already_processed, namespace_, name_='cntA')
    def exportChildren(self, outfile, level, namespace_='m2m:', name_='cntA', fromsubclass_=False, pretty_print=True):
        super(cntA, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.st is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sst>%s</%sst>%s' % (namespace_, self.gds_format_integer(self.st, input_name='st'), namespace_, eol_))
        if self.mni is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smni>%s</%smni>%s' % (namespace_, self.gds_format_integer(self.mni, input_name='mni'), namespace_, eol_))
        if self.mbs is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smbs>%s</%smbs>%s' % (namespace_, self.gds_format_integer(self.mbs, input_name='mbs'), namespace_, eol_))
        if self.mia is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smia>%s</%smia>%s' % (namespace_, self.gds_format_integer(self.mia, input_name='mia'), namespace_, eol_))
        if self.cni is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scni>%s</%scni>%s' % (namespace_, self.gds_format_integer(self.cni, input_name='cni'), namespace_, eol_))
        if self.cbs is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scbs>%s</%scbs>%s' % (namespace_, self.gds_format_integer(self.cbs, input_name='cbs'), namespace_, eol_))
        if self.li is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sli>%s</%sli>%s' % (namespace_, self.gds_format_string(quote_xml(self.li).encode(ExternalEncoding), input_name='li'), namespace_, eol_))
        if self.or_ is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sor>%s</%sor>%s' % (namespace_, self.gds_format_string(quote_xml(self.or_).encode(ExternalEncoding), input_name='or'), namespace_, eol_))
        for ch_ in self.ch:
            ch_.export(outfile, level, namespace_, name_='ch', pretty_print=pretty_print)
        for cin_ in self.cin:
            cin_.export(outfile, level, namespace_='m2m:', name_='cin', pretty_print=pretty_print)
        for cinA_ in self.cinA:
            cinA_.export(outfile, level, namespace_='m2m:', name_='cinA', pretty_print=pretty_print)
        for cnt_ in self.cnt:
            cnt_.export(outfile, level, namespace_='m2m:', name_='cnt', pretty_print=pretty_print)
        for cntA_ in self.cntA:
            cntA_.export(outfile, level, namespace_='m2m:', name_='cntA', pretty_print=pretty_print)
        for sub_ in self.sub:
            sub_.export(outfile, level, namespace_='m2m:', name_='sub', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(cntA, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'st':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'st')
            self.st = ival_
        elif nodeName_ == 'mni':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'mni')
            self.mni = ival_
        elif nodeName_ == 'mbs':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'mbs')
            self.mbs = ival_
        elif nodeName_ == 'mia':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'mia')
            self.mia = ival_
        elif nodeName_ == 'cni':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'cni')
            self.cni = ival_
        elif nodeName_ == 'cbs':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'cbs')
            self.cbs = ival_
        elif nodeName_ == 'li':
            li_ = child_.text
            li_ = self.gds_validate_string(li_, node, 'li')
            self.li = li_
        elif nodeName_ == 'or':
            or_ = child_.text
            or_ = self.gds_validate_string(or_, node, 'or')
            self.or_ = or_
        elif nodeName_ == 'ch':
            obj_ = childResourceRef.factory()
            obj_.build(child_)
            self.ch.append(obj_)
            obj_.original_tagname_ = 'ch'
        elif nodeName_ == 'cin':
            obj_ = cin.factory()
            obj_.build(child_)
            self.cin.append(obj_)
            obj_.original_tagname_ = 'cin'
        elif nodeName_ == 'cinA':
            obj_ = cinA.factory()
            obj_.build(child_)
            self.cinA.append(obj_)
            obj_.original_tagname_ = 'cinA'
        elif nodeName_ == 'cnt':
            obj_ = cnt.factory()
            obj_.build(child_)
            self.cnt.append(obj_)
            obj_.original_tagname_ = 'cnt'
        elif nodeName_ == 'cntA':
            obj_ = cntA.factory()
            obj_.build(child_)
            self.cntA.append(obj_)
            obj_.original_tagname_ = 'cntA'
        elif nodeName_ == 'sub':
            obj_ = sub.factory()
            obj_.build(child_)
            self.sub.append(obj_)
            obj_.original_tagname_ = 'sub'
        super(cntA, self).buildChildren(child_, node, nodeName_, True)
# end class cntA


class cnt(announceableResource):
    subclass = None
    superclass = announceableResource
    def __init__(self, rn=None, ty=None, ri=None, pi=None, ct=None, lt=None, lbl=None, acpi=None, et=None, at=None, aa=None, st=None, cr=None, mni=None, mbs=None, mia=None, cni=None, cbs=None, li=None, or_=None, la=None, ol=None, ch=None, cin=None, cnt_member=None, sub=None):
        self.original_tagname_ = None
        super(cnt, self).__init__(rn, ty, ri, pi, ct, lt, lbl, acpi, et, at, aa, )
        self.st = st
        self.cr = cr
        self.validate_ID(self.cr)
        self.mni = mni
        self.mbs = mbs
        self.mia = mia
        self.cni = cni
        self.cbs = cbs
        self.li = li
        self.or_ = or_
        self.la = la
        self.ol = ol
        # if ch is None:
        #     self.ch = []
        # else:
        #     self.ch = ch
        # if cin is None:
        #     self.cin = []
        # else:
        #     self.cin = cin
        # if cnt_member is None:
        #     self.cnt = []
        # else:
        #     self.cnt = cnt_member
        # if sub is None:
        #     self.sub = []
        # else:
        #     self.sub = sub
    def factory(*args_, **kwargs_):
        if cnt.subclass:
            return cnt.subclass(*args_, **kwargs_)
        else:
            return cnt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_st(self): return self.st
    def set_st(self, st): self.st = st
    def get_cr(self): return self.cr
    def set_cr(self, cr): self.cr = cr
    def get_mni(self): return self.mni
    def set_mni(self, mni): self.mni = mni
    def get_mbs(self): return self.mbs
    def set_mbs(self, mbs): self.mbs = mbs
    def get_mia(self): return self.mia
    def set_mia(self, mia): self.mia = mia
    def get_cni(self): return self.cni
    def set_cni(self, cni): self.cni = cni
    def get_cbs(self): return self.cbs
    def set_cbs(self, cbs): self.cbs = cbs
    def get_li(self): return self.li
    def set_li(self, li): self.li = li
    def get_or(self): return self.or_
    def set_or(self, or_): setattr(self, "or", or_)
    def get_la(self): return self.la
    def set_la(self, la): self.la = la
    def get_ol(self): return self.ol
    def set_ol(self, ol): self.ol = ol
    def get_ch(self): return self.ch
    def set_ch(self, ch): self.ch = ch
    def add_ch(self, value): self.ch.append(value)
    def insert_ch_at(self, index, value): self.ch.insert(index, value)
    def replace_ch_at(self, index, value): self.ch[index] = value
    def get_cin(self): return self.cin
    def set_cin(self, cin): self.cin = cin
    def add_cin(self, value): self.cin.append(value)
    def insert_cin_at(self, index, value): self.cin.insert(index, value)
    def replace_cin_at(self, index, value): self.cin[index] = value
    def get_cnt(self): return self.cnt
    def set_cnt(self, cnt): self.cnt = cnt
    def add_cnt(self, value): self.cnt.append(value)
    def insert_cnt_at(self, index, value): self.cnt.insert(index, value)
    def replace_cnt_at(self, index, value): self.cnt[index] = value
    def get_sub(self): return self.sub
    def set_sub(self, sub): self.sub = sub
    def add_sub(self, value): self.sub.append(value)
    def insert_sub_at(self, index, value): self.sub.insert(index, value)
    def replace_sub_at(self, index, value): self.sub[index] = value
    def validate_ID(self, value):
        # Validate type ID, a restriction on xs:anyURI.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.st is not None or
            self.cr is not None or
            self.mni is not None or
            self.mbs is not None or
            self.mia is not None or
            self.cni is not None or
            self.cbs is not None or
            self.li is not None or
            self.or_ is not None or
            self.la is not None or
            self.ol is not None or
            self.ch or
            self.cin or
            self.cnt or
            self.sub or
            super(cnt, self).hasContent_()
        ):
            return True
        else:
            return False


    def to_JSON(self):
        self.payload = {"m2m:cnt":{k: v for k, v in self.__dict__.iteritems() if v is not None}}
        return json.dumps(self, default=lambda o: o.payload,
            sort_keys=True, indent=4)



    def export(self, outfile, level, namespace_='m2m:', name_='cnt', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='cnt')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='m2m:', name_='cnt', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='m2m:', name_='cnt'):
        super(cnt, self).exportAttributes(outfile, level, already_processed, namespace_, name_='cnt')
    def exportChildren(self, outfile, level, namespace_='m2m:', name_='cnt', fromsubclass_=False, pretty_print=True):
        super(cnt, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.st is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sst>%s</%sst>%s' % (namespace_, self.gds_format_integer(self.st, input_name='st'), namespace_, eol_))
        if self.cr is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scr>%s</%scr>%s' % (namespace_, self.gds_format_string(quote_xml(self.cr).encode(ExternalEncoding), input_name='cr'), namespace_, eol_))
        if self.mni is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smni>%s</%smni>%s' % (namespace_, self.gds_format_integer(self.mni, input_name='mni'), namespace_, eol_))
        if self.mbs is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smbs>%s</%smbs>%s' % (namespace_, self.gds_format_integer(self.mbs, input_name='mbs'), namespace_, eol_))
        if self.mia is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smia>%s</%smia>%s' % (namespace_, self.gds_format_integer(self.mia, input_name='mia'), namespace_, eol_))
        if self.cni is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scni>%s</%scni>%s' % (namespace_, self.gds_format_integer(self.cni, input_name='cni'), namespace_, eol_))
        if self.cbs is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scbs>%s</%scbs>%s' % (namespace_, self.gds_format_integer(self.cbs, input_name='cbs'), namespace_, eol_))
        if self.li is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sli>%s</%sli>%s' % (namespace_, self.gds_format_string(quote_xml(self.li).encode(ExternalEncoding), input_name='li'), namespace_, eol_))
        if self.or_ is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sor>%s</%sor>%s' % (namespace_, self.gds_format_string(quote_xml(self.or_).encode(ExternalEncoding), input_name='or'), namespace_, eol_))
        if self.la is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sla>%s</%sla>%s' % (namespace_, self.gds_format_string(quote_xml(self.la).encode(ExternalEncoding), input_name='la'), namespace_, eol_))
        if self.ol is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sol>%s</%sol>%s' % (namespace_, self.gds_format_string(quote_xml(self.ol).encode(ExternalEncoding), input_name='ol'), namespace_, eol_))
        for ch_ in self.ch:
            ch_.export(outfile, level, namespace_, name_='ch', pretty_print=pretty_print)
        for cin_ in self.cin:
            cin_.export(outfile, level, namespace_='m2m:', name_='cin', pretty_print=pretty_print)
        for cnt_ in self.cnt:
            cnt_.export(outfile, level, namespace_='m2m:', name_='cnt', pretty_print=pretty_print)
        for sub_ in self.sub:
            sub_.export(outfile, level, namespace_='m2m:', name_='sub', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(cnt, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'st':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'st')
            self.st = ival_
        elif nodeName_ == 'cr':
            cr_ = child_.text
            cr_ = self.gds_validate_string(cr_, node, 'cr')
            self.cr = cr_
            # validate type ID
            self.validate_ID(self.cr)
        elif nodeName_ == 'mni':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'mni')
            self.mni = ival_
        elif nodeName_ == 'mbs':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'mbs')
            self.mbs = ival_
        elif nodeName_ == 'mia':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'mia')
            self.mia = ival_
        elif nodeName_ == 'cni':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'cni')
            self.cni = ival_
        elif nodeName_ == 'cbs':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'cbs')
            self.cbs = ival_
        elif nodeName_ == 'li':
            li_ = child_.text
            li_ = self.gds_validate_string(li_, node, 'li')
            self.li = li_
        elif nodeName_ == 'or':
            or_ = child_.text
            or_ = self.gds_validate_string(or_, node, 'or')
            self.or_ = or_
        elif nodeName_ == 'la':
            la_ = child_.text
            la_ = self.gds_validate_string(la_, node, 'la')
            self.la = la_
        elif nodeName_ == 'ol':
            ol_ = child_.text
            ol_ = self.gds_validate_string(ol_, node, 'ol')
            self.ol = ol_
        elif nodeName_ == 'ch':
            obj_ = childResourceRef.factory()
            obj_.build(child_)
            self.ch.append(obj_)
            obj_.original_tagname_ = 'ch'
        elif nodeName_ == 'cin':
            obj_ = cin.factory()
            obj_.build(child_)
            self.cin.append(obj_)
            obj_.original_tagname_ = 'cin'
        elif nodeName_ == 'cnt':
            obj_ = cnt.factory()
            obj_.build(child_)
            self.cnt.append(obj_)
            obj_.original_tagname_ = 'cnt'
        elif nodeName_ == 'sub':
            obj_ = sub.factory()
            obj_.build(child_)
            self.sub.append(obj_)
            obj_.original_tagname_ = 'sub'
        super(cnt, self).buildChildren(child_, node, nodeName_, True)
# end class cnt


GDSClassesMapping = {
    'rt': responseTypeInfo,
    'rl': rateLimit,
    'ch': childResourceRef,
    'dld': downloadArgsType,
    'swup': softwareUpdateArgsType,
    'bn': batchNotify,
    'req': reqType,
    'mi': metaInformation,
    'enc': eventNotificationCriteria,
    'rbo': rebootArgsType,
    'pc': primitiveContent,
    'swin': softwareInstallArgsType,
    'fc': filterCriteria,
    'atr': attribute,
    'se': scheduleEntries,
    'swun': softwareUninstallArgsType,
    'rst': resetArgsType,
    'any': anyArgType,
    'uld': uploadArgsType,
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'cnt'
        rootClass = cnt
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='xmlns:m2m="http://www.onem2m.org/xml/protocols"',
            pretty_print=True)
    return rootObj


def parseEtree(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'cnt'
        rootClass = cnt
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(content)
        sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False):
    from StringIO import StringIO
    parser = None
    doc = parsexml_(StringIO(inString), parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'cnt'
        rootClass = cnt
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='xmlns:m2m="http://www.onem2m.org/xml/protocols"')
    return rootObj


def parseLiteral(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'cnt'
        rootClass = cnt
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('#from container import *\n\n')
        sys.stdout.write('import container as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "actionStatus",
    "aggregatedRequest",
    "announceableResource",
    "announceableSubordinateResource",
    "announcedMgmtResource",
    "announcedResource",
    "announcedSubordinateResource",
    "anyArgType",
    "attribute",
    "batchNotify",
    "childResourceRef",
    "cin",
    "cinA",
    "cnt",
    "cntA",
    "deliveryMetaData",
    "downloadArgsType",
    "eventNotificationCriteria",
    "execReqArgsListType",
    "filterCriteria",
    "metaInformation",
    "mgmtLinkRef",
    "mgmtResource",
    "operationResult",
    "primitiveContent",
    "rateLimit",
    "rebootArgsType",
    "regularResource",
    "reqType",
    "resetArgsType",
    "resource",
    "responseTypeInfo",
    "sch",
    "schA",
    "scheduleEntries",
    "softwareInstallArgsType",
    "softwareUninstallArgsType",
    "softwareUpdateArgsType",
    "sub",
    "uploadArgsType"
]
